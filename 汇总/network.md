【计算机网络进阶路线】

网络相关知识点

[https://juejin.im/post/5b7be0b2e51d4538db34a51e](https://juejin.im/post/5b5f20686fb9a04f844adbdd)

计算机网络问题面试集锦

https://blog.csdn.net/justloveyou_/article/details/78303617

### **http**和**https**的区别

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

开销：Https通信需要证书，而证书一般需要向认证机构购买；

### 什么是**HTTPS**

https://mp.weixin.qq.com/s/1ojSrhc9LZV8zlX6YblMtA

### 对称加密和非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

常见对称加密：

DES、3DES、AES、Blowfish、IDEA、RC5、RC6

常见非对称加密：

RSA、DSA、ECC

### 三次握手和四次分手

https://github.com/jawil/blog/issues/14

### 为什么**TCP**链接需要三次握手，两次不可以吗

为了防止 **已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这时，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

### **TCP**协议如何保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

对于可靠性，TCP通过以下方式进行保证：

**数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

**对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

**丢弃重复数据**：对于重复数据，能够丢弃重复数据；

**应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

**超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

### 客户端不断进行请求链接会怎么样？**DDOS**攻击？

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

DDOS攻击：

客户端向服务端发送请求链接数据包

服务端向客户端发送确认数据包

客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDOS预防(无法根治，除非不使用TCP)：

加宽带、封IP、CDN服务

限制同时打开SYN半链接的数目

缩短SYN半链接的Time out 时间

关闭不必要的服务

### **GET**和**POST**区别

从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源。

从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 **请求头** 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体** 中。

从安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

### **TCP**和**UDP**区别

TCP是面向连接的，UDP是无连接的；

TCP是可靠的，UDP是不可靠的；

TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

TCP是面向字节流的，UDP是面向报文的；

TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信

TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

### **TCP**的拥堵处理

计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，**拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。**拥塞控制的方法主要有以下四种：

1). **慢启动：**不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;

2). **拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

3). **快重传：**快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

4). **快恢复：**快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。

### **Session**和**Cookie**的对比

实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

### **SQL** 注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**SQL**注入攻击的整体思路

寻找到SQL注入的位置；判断服务器类型和后台数据库类型；针对不通的服务器和数据库特点进行SQL注入攻击。

**SQL**注入攻击实例

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成：SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’。分析上述SQL语句我们知道，

username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**SQL**注入攻击的应对方法

预编译；

正则表达式过滤对应的参数

**XSS**攻击

◦ XSS攻击的危害

◦ XSS攻击的原因解析

◦ XSS攻击分类

◦ 修复漏洞方针

**OSI**网络体系结构与**TCP/IP**协议模型

◦

### **TCP**和**UDP**分别对应的常见应用层协议

TCP对应的应用层协议：

FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

UDP层对应的协议：

DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

网络层的**ARP**协议(链路层协议)工作原理

**网络层的****ARP****协议完成了****IP****地址与物理地址的映射。**首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

### **IP**地址的分类

https://blog.csdn.net/justloveyou_/article/details/78303617

### **IP**地址与物理地址

物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，ARP协议用于IP地址和物理地址的对应。

常见状态码

### 从**url**输入到页面展现到底发生什么

https://juejin.im/post/5c773dd251882519610194c1

### **Https**的通信流程（图解**HTTP**）

客户端向服务器发起SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表（所使用的加密算法及密钥长度）

服务器的响应报文中，包含SSL版本以及加密组件，服务器的加密组件内容是从客户端发来的加密组件列表中筛选出来的，服务器还会发一个公开密钥并且带有公钥证书

客户端拿到服务器的公开密钥，并验证其公钥证书（使用浏览器中已经植入的CA公开密钥）

如果验证成功，客户端生成一个Pre-master secret随机密码串，这个随机密码串其实就是之后通信要用的对称密钥，并用服务器的公开密钥进行加密，发送给服务器，以此通知服务器，之后的报文都会通过这个对称密钥来加密

同时，客户端用约定好的hash算法计算握手消息，然后用生成的密钥进行加密，一起发送给服务器

服务器收到客户端发来的的公开密钥加密的对称密钥，用自己的私钥对其解密拿到对称密钥，再用对称密钥解析握手消息，验证hash值是否与客户端发来的一致。如果一致，则通知客户端SSL握手成功

之后的数据交互都是HTTP通信（当然通信会获得SSL保护），且数据都是通过对称密钥来加密（这个密钥不会每次都发，在握手的过程中，服务器已经知道了这个对称密钥，再有数据来时，服务器知道这些数据就是通过对称密钥加密的，于是就直接解密了）

### 长连接与短连接

https://www.cnblogs.com/0201zcr/p/4694945.html

### tcp什么时候有RST

> RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。

#### 产生产生原因：

- SYN数据段指定的目的端口处没有接收进程在等待。

> 常见的例子是终端访问未开放的端口，服务器回复RST报文。比如，访问Web服务器的21(FTP )端口,如果该端口的服务未开放或者阻断了到该端口的报文，则服务器很可能会给终端SYN报文回应一个RST报文。因此服务器对终端SYN报文响应RST报文在很多时候可以作为端口扫描判断目标端口未开放的一个可靠依据。当然，大多数场景下，服务器对到达自身未监听端口的报文进行丢弃而不响应是一种更为安全的实现

- TCP想放弃一个已经存在的链接。

> 正常拆除一个已有TCP连接的方式是发送FIN，FIN报文会在所有排队数据都发出后才会发送，正常情况下不会有数据丢失，因此，这也被称为是有序释放。另外一种拆除已有TCP连接的方式就是发送RST，这种方式的优点在于无需等待数据传输完毕，可以立即终结连接，这种通过RST拆除连接的方式被称为异常释放。大多数时候服务器需要针对两种不同的拆链方式提供不同的处理方法，也有很多服务器无法识别RST方式的拆链，这时候就需要格外小心，因为一旦出现这种情况，尤其是大量终端使用RST方式拆链，可能会导致服务器侧连接无法得到有效释放，影响其正常业务侧处理能力。

- TCP接收到一个数据段，但是这个数据段所标识的连接不存在。

> TCP通过4元组（源目IP，源目端口）唯一的标识一个连接，由于TCP状态机的存在，触发TCP连接建立的第一个报文标志位一定是SYN置位，因此，当服务器接收到一个新四元组（服务器本地没有这个连接）的非SYN首包就会丢弃该报文并向终端响应一个RST报文。

[[为什么服务器突然回复RST——小心网络中的安全设备](https://www.cnblogs.com/yurang/p/11980464.html)](https://www.cnblogs.com/yurang/p/11980464.html)

### TCP状态机：当服务端主动发FIN进TIME_WAIT，客户端源端口复用会发生什么

[TCP状态机：当服务端主动发FIN进TIME_WAIT，客户端源端口复用会发生什么](https://www.cnblogs.com/yurang/p/12154453.html)

### RPC和HTTP的区别

https://www.cnblogs.com/liang1101/p/13083965.html

### Tcp报文简介以及头部选项字段(Tcp Options字段)

#### **Tcp 报文格式简介**

1. tcp报文由tcp header和tcp数据组成。
2. **tcp header 的最大长度为60字节**，而**必须要有的固定长度**也就是图一的前5层的**20字节**，每层占有32bit，也就是32/8=4字节，5层，5*4 = 20字节，那么第六层的可选项和填充也就是**Tcp Options字段最大为60-20=40字节。**填充是为了使TCP首部为4字节（32bit）的整数倍。

### 半连接、半打开、半关闭

#### 半连接

定义

发生在TCP3次握手中。

如果A向B发起TCP请求，B也按照正常情况进行响应了，但是A不进行第3次握手，这就是半连接。

#### 半连接攻击

半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。

#### 半打开

如果一方已经关闭或异常终止连接，而另一方却不知道。 我们将这样的TCP连接称为半打开（Half-Open）。

#### 半关闭

TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是TCP的半关闭。

当一方关闭发送通道后，仍可接受另一方发送过来的数据，这样的情况叫“半关闭”。（拆除TCP连接是：你关闭你的发送通道，我关闭我的发送通道）。

#### 半关闭的产生

客户端发送FIN，另一端发送对这个FIN的ACK报文段。 此时客户端就处于半关闭。

### 什么是中间人攻击

https://juejin.cn/post/6844904065227292685