### 对称加密和非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

常见对称加密：

DES、3DES、AES、Blowfish、IDEA、RC5、RC6

常见非对称加密：

RSA、DSA、ECC



### 客户端不断进行请求链接会怎么样？**DDOS**攻击？

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

DDOS攻击：

客户端向服务端发送请求链接数据包

服务端向客户端发送确认数据包

客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDOS预防(无法根治，除非不使用TCP)：

加宽带、封IP、CDN服务

限制同时打开SYN半链接的数目

缩短SYN半链接的Time out 时间

关闭不必要的服务

### **GET**和**POST**区别

从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源。

从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 **请求头** 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体** 中。

从安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

### **Session**和**Cookie**的对比

实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

### **SQL** 注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**SQL**注入攻击的整体思路

寻找到SQL注入的位置；判断服务器类型和后台数据库类型；针对不通的服务器和数据库特点进行SQL注入攻击。

**SQL**注入攻击实例

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成：SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’。分析上述SQL语句我们知道，

username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**SQL**注入攻击的应对方法

预编译；

正则表达式过滤对应的参数

**XSS**攻击

◦ XSS攻击的危害

◦ XSS攻击的原因解析

◦ XSS攻击分类

◦ 修复漏洞方针

**OSI**网络体系结构与**TCP/IP**协议模型



### **TCP**和**UDP**分别对应的常见应用层协议

TCP对应的应用层协议：

FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

UDP层对应的协议：

DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

网络层的**ARP**协议(链路层协议)工作原理

**网络层的****ARP****协议完成了****IP****地址与物理地址的映射。**首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

### **IP**地址的分类

https://blog.csdn.net/justloveyou_/article/details/78303617

### **IP**地址与物理地址

物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，ARP协议用于IP地址和物理地址的对应。

常见状态码

### 从**url**输入到页面展现到底发生什么

https://juejin.im/post/5c773dd251882519610194c1



### 长连接与短连接

https://www.cnblogs.com/0201zcr/p/4694945.html

### tcp什么时候有RST

> RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。

#### 产生产生原因：

- SYN数据段指定的目的端口处没有接收进程在等待。

> 常见的例子是终端访问未开放的端口，服务器回复RST报文。比如，访问Web服务器的21(FTP )端口,如果该端口的服务未开放或者阻断了到该端口的报文，则服务器很可能会给终端SYN报文回应一个RST报文。因此服务器对终端SYN报文响应RST报文在很多时候可以作为端口扫描判断目标端口未开放的一个可靠依据。当然，大多数场景下，服务器对到达自身未监听端口的报文进行丢弃而不响应是一种更为安全的实现

- TCP想放弃一个已经存在的链接。

> 正常拆除一个已有TCP连接的方式是发送FIN，FIN报文会在所有排队数据都发出后才会发送，正常情况下不会有数据丢失，因此，这也被称为是有序释放。另外一种拆除已有TCP连接的方式就是发送RST，这种方式的优点在于无需等待数据传输完毕，可以立即终结连接，这种通过RST拆除连接的方式被称为异常释放。大多数时候服务器需要针对两种不同的拆链方式提供不同的处理方法，也有很多服务器无法识别RST方式的拆链，这时候就需要格外小心，因为一旦出现这种情况，尤其是大量终端使用RST方式拆链，可能会导致服务器侧连接无法得到有效释放，影响其正常业务侧处理能力。

- TCP接收到一个数据段，但是这个数据段所标识的连接不存在。

> TCP通过4元组（源目IP，源目端口）唯一的标识一个连接，由于TCP状态机的存在，触发TCP连接建立的第一个报文标志位一定是SYN置位，因此，当服务器接收到一个新四元组（服务器本地没有这个连接）的非SYN首包就会丢弃该报文并向终端响应一个RST报文。

[[为什么服务器突然回复RST——小心网络中的安全设备](https://www.cnblogs.com/yurang/p/11980464.html)](https://www.cnblogs.com/yurang/p/11980464.html)

### TCP状态机：当服务端主动发FIN进TIME_WAIT，客户端源端口复用会发生什么

[TCP状态机：当服务端主动发FIN进TIME_WAIT，客户端源端口复用会发生什么](https://www.cnblogs.com/yurang/p/12154453.html)

### RPC和HTTP的区别

https://www.cnblogs.com/liang1101/p/13083965.html



### 什么是中间人攻击

https://juejin.cn/post/6844904065227292685