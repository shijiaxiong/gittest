【操作系统】

操作系统面试问题集锦

https://blog.csdn.net/justloveyou_/article/details/78304294

操作系统常见面试题整理

https://zhuanlan.zhihu.com/p/23755202

进程和线程的区别

进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程间的通讯方式

管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

线程同步方式

互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

什么是死锁

在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

死锁产生的四个必要条件

互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；

占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；

非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放

循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

死锁的处理基本策略和常用方法

(**1**)**.** 死锁预防

死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法包括：

打破互斥条件：允许进程同时访问某些资源。但是，有些资源是不能被多个进程所共享的，这是由资源本身属性所决定的，因此，这种办法通常并无实用价值。

打破占有并等待条件：可以实行资源预先分配策略(进程在运行前一次性向系统申请它所需要的全部资源，若所需全部资源得不到满足，则不分配任何资源，此进程暂不运行；只有当系统能满足当前进程所需的全部资源时，才一次性将所申请资源全部分配给该线程)或者只允许进程在没有占用资源时才可以申请资源（一个进程可申请一些资源并使用它们，但是在当前进程申请更多资源之前，它必须全部释放当前所占有的资源）。但是这种策略也存在一些缺点：在很多情况下，无法预知一个进程执行前所需的全部资源，因为进程是动态执行的，不可预知的；同时，会降低资源利用率，导致降低了进程的并发性。

打破非抢占条件：允许进程强行从占有者哪里夺取某些资源。也就是说，但一个进程占有了一部分资源，在其申请新的资源且得不到满足时，它必须释放所有占有的资源以便让其它线程使用。这种预防死锁的方式实现起来困难，会降低系统性能。

打破循环等待条件：实行资源有序分配策略。对所有资源排序编号，所有进程对资源的请求必须严格按资源序号递增的顺序提出，即只有占用了小号资源才能申请大号资源，这样就不回产生环路，预防死锁的发生。

(**2**)**.** 死锁避免的基本思想

死锁避免的基本思想是动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。资源分配图算法和银行家算法是两种经典的死锁避免的算法，其可以确保系统始终处于安全状态。其中，资源分配图算法应用场景为每种资源类型只有一个实例(申请边，分配边，需求边，不形成环才允许分配)，而银行家算法应用于每种资源类型可以有多个实例的场景。

　　(**3**)**.** 死锁解除

　　死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源，此时必须考虑三个问题：

　　(I). 选择一个牺牲品

　　(II). 回滚：回滚到安全状态

　　(III). 饥饿（在代价因素中加上回滚次数，回滚的越多则越不可能继续被作为牺牲品，避免一个进程总是被回滚）

进程有哪几种状态

就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；

运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；

阻塞状态： 进程等待某种条件，在条件满足之前无法执行；

线程有几种状态

创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。

操作系统进程调度的策略

**FCFS****(先来先服务，队列实现，非抢占的)**：先请求CPU的进程先分配到CPU

**SJF****(最短作业优先调度算法)**：平均等待时间最短，但难以知道下一个CPU区间长度

**优先级调度算法(可以是抢占的，也可以是非抢占的)**：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化

**时间片轮转调度算法(可抢占的)**：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

**多级队列调度算法**：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。

**多级反馈队列调度算法**：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

进程同步有哪几种机制

原子操作、信号量机制、自旋锁管程、会合、分布式系统

◦ awk的使用

◦ Linux常用命令-压缩、解压、查看日志、查看负载、文件查找

**Nginx**的工作原理？**Nginx**，**PHP-fpm**的工作机制？

https://blog.csdn.net/hguisu/article/details/8930668

**Nginx Access Log**日志统计分析常用命令

https://www.cnblogs.com/coolworld/p/6726538.html

access.log前十的访问ip：cat access.log | awk '{print $1}'|sort |uniq -c |sort -nr |head -n 10

504 出现次数：cat access.log | grep ‘504’ | wc -l

**nginx**与**php-fpm**通信的两种方式

https://blog.csdn.net/koastal/article/details/52303316



##  Q:Linux的五种IO模型

> 阻塞式和非阻塞式最大的区别就是阻塞式在等待数据阶段会进入阻塞，而非阻塞式不会。

### 阻塞IO(Blocking I/O)

- 对一个文件描述符操作(FD)时，如果操作没有响应就会一直等待，直到内核有反馈。
- 缺点：单线程一次只能操作一个FD。

### 非阻塞IO(Nonblocking I/O)

- 对FD操作时，如果内核没反馈不会一直等待。非阻塞I/O会将所有FD放入FD set，一直轮询所有FD，直到有反馈。
- 缺点：每次轮询没有时间的FD也会被操作，浪费CPU。

### 信号驱动I/O(Signal Driven I/O)

- 信号驱动IO是首先注册signal handler,当有时间到来时，内核会向进程发送信号，然后应用进程执行signal handler
- 缺点：编程难度高，信号处理复杂。

### 异步I/O(Asynchronous I/O)

- 信号驱动I/O是FD满足条件时内核通知应用程序可以开始I/O了，而异步I/O是应用程序将I/O操作交给内核，当内核做完之后再通知应用程序I/O完成。
- 缺点：并发量不好控制。

### IO多路复用(I/O Multiplexing)

- IO多路复用，重点是，应用层可以把多个socket连接注册给操作系统，让操作系统帮忙盯着这些socket有没有数据过来（可读/可写），注册完成之后，应用层就可以去干别的事了。当socket有数据过来时，操作系统会通知应用层，应用层再去处理。这样的优势在于应用层1个线程，就可以服务多个网络请求。



## Q:IO多路复用

### select

- select使用BitsMap来传入和接受FD，每次调用都会在用户空间和内核空间之间拷贝。
- select的BitsMap限制只能监听FD 0~1023。
- 轮询的方式监听所有FD，𝑂(𝑛)的复杂度。
- select 的 timeout 精度为 1ns，而其他两种为 1ms
- 可移植性好

#### 工作方式

> 需要进行 2 次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生 2 次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。

- 将已连接的Socket放到一个`文件描述符集合`，然后调用select函数将文件描述符集合`拷贝`到内核里。
- 内核通过`遍历`we年描述符集合的方式检查是否有网络事件产生。
- 当检查到有事件产生后，将此Socket标记为可读或可写。把整个文件描述符集合拷贝回用户态。
- 用户态再遍历的方法找到可读或可写的Socket，然后进行处理。

### poll

- poll和select的区别就是BitsMap换成了链表，FD数量只受poll可用内核内存大小限制。

- 轮询的方式监听所有FD，𝑂(𝑛)的复杂度。

  

### epoll

- epoll只有在epoll-ctl(ADD)时将数据拷入，epoll_wait时再将数据拷出，多次复用没有其他数据拷贝，节省了数据拷贝。
- 时间复杂度为O(logn)

#### 工作方式

-  epoll在内核里使用**红黑树来跟踪所有待检测的文件描述符**，把需要监控的sokcet通过`epoll_ctl()`函数加入内核中的红黑树里。
- epoll使用时间驱动的机制，内核里**维护了一个链表来记录就绪时间**，当某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用`epoll_wait()`时，返回有时间发生的文件描述符个数。

#### 触发模式

- **边缘触发（edge-triggered，ET）：**当被监控的 Socket 描述符上有可读事件发生时，服务器只会从epoll_wait中苏醒一次。一般和非阻塞IO搭配使用。
- **水平触发（level-triggered，LT）：**当被监控的 Socket 描述符上有可读事件发生时。服务器端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束。



[IO复用 各自的应用场景](https://juejin.cn/post/6844903810322661390)
[Linux IO多路复用机制](https://journey-c.github.io/io-multiplexing/)

[一次搞定网络IO](https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA)

### Docker

#### Namespaces

命名空间 (namespaces) 是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。Docker 其实就通过 Linux 的 Namespaces 对不同的容器实现了隔离。

#### CGROUPS

CGroups就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。

#### UnionFS

