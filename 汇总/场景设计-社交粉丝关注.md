## 关注关系底层数据结构的设计需求

- 查看某个用户的关注列表。
- 查看某个用户的粉丝列表。
- 查看某个人的互相关注列表。
- 判断两个用户之间的关系。（在微博中,你查看别人主页时左下角的集中状态）
- 获取两个人的共同关注。（微博中查看别人的关注列表时会有这个栏目,展示你和他共同关注的一些人）



## 关系型数据库mysql实现

**follow(关注关系表)**

| 字段名        | 类型                                        | 索引        | 注解                    |
| :------------ | :------------------------------------------ | :---------- | :---------------------- |
| id            | bigint                                      | primary-key | 主键ID                  |
| user_id       | bigint->unsigned()->notNull()               | normal      | 用户-被关注             |
| followed_user | bigint->unsigned()->notNull()               |             | 关注的人的id            |
| status        | smallInteger()->unsigned()->defaultValue(1) |             | 关注状态:是否取消关注等 |
| created_at    |                                             | normal      |                         |
| updated_at    |                                             | normal      |                         |

- 用户每关注一个人，就产生一条数据。
- 当关注数量过大的时候会查询复杂。需要分库分表。

压缩数据行数：

- 压缩数据行数，使用text格式存储数据，对应字段中存储json格式。
- 这种情况对于大V他的粉丝会非常多。查询计算太消耗资源。也可能会有热点数据问题。

###  弱关系

- 建立一张粉丝表和一张关注表。关注表记录了用户记录uid所有关注用户。粉丝表记录uid所有粉丝用户。
- 一个关注会产生两条数据。





## Redis hash实现

- 每个用户对应两个hash表，一个存储关注信息，另一个存储粉丝。
- hash可以存储2^32-1条数据。

```c
hash
	field:关注用户Id
	value:关注时间
```

### 缺点

- hgetAll在数据量较大的时候可能会超时。数据量较大时返回结果是无序的。
- 较大集合的数据在cache miss之后，重建缓存压力大。影响可用性。



## Redis Sorted Set实现

- 每个用户对应两个集合。单个集合可以存储2^32-1条数据。
- 获取列表的时候使用zrange，返回有序集合指定范围的成员。
- 使用`ZINTERSTORE`计算交集。



## 分布式Nosql tablestore





## Feed流设计

#### 主要关注点

- 流的数据层
  - 发布者数据
  - 关注关系
  - 接受者数据
- 存储：发布者数据存储
- 关系表：用户关系表。
- 同步库：存储接收者的时间热度数据，只需要保留最近一段时间的数据即可。
- 用户规模
- 关注关系(单向、双向)

[知乎、微博feed流](https://app.yinxiang.com/shard/s43/nl/13675070/1c3f2b46-1315-4d0c-8890-eb7a131527ea)



