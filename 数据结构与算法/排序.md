## 常见算法

> **内排序**：所有排序操作都在内存中完成，适用于数据规模不是特别大的情况；
> **外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

> **稳定性**：经过排序后相同元素原有的顺序不变，就是稳定的


| 排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度               | 稳定性 | 排序方式 |
| -------- | -------------- | -------- | -------- | ------------------------ | ------ | -------- |
| 冒泡排序 | O(n^2)         |          |          | O(1)                     | 稳定   | 内       |
| 选择排序 | O(n^2)         |          |          | O(1)                     | 不稳定 | 内       |
| 插入排序 | O(n^2)         |          |          | O(1)                     | 稳定   | 内       |
| 希尔排序 | O(nlogn)       |          |          | O(1)                     |        | 内       |
| 快速排序 | O(nlogn)       |          |          | O(logn) - 递归栈空间开销 | 不稳定 | 内       |
| 归并排序 | O(nlogn)       |          |          | O(n)                     | 稳定   | 外排序   |
| 堆排序   | O(nlogn)       |          |          | O(1)                     | 不稳定 | 内       |
| 桶排序   | O(n)           |          |          |                          | 稳定   | 外排序   |
| 计数排序 |                |          |          |                          | 稳定   | 外排序   |
| 基数排序 | O(n)           |          |          |                          | 稳定   | 外排序   |



### 冒泡排序

#### 思路：

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到数组有序，排序完成。

```go
func bubbleSort(nums []int) []int {
	// 第一层循环是元素的个数
	for i := 0; i < len(nums);i++ {
		// 先默认数组是有序的，只要发生一次交换，就必须进行下一轮比较，
		// 如果在内层循环中，都没有执行一次交换操作，说明此时数组已经是升序数组
		sorted := true

		// 第二层循环是比较的次数
		for j := 0; j < len(nums) - i - 1; j++ {
			if nums[j] > nums[j+1] {
				nums[j], nums[j + 1] = nums[j + 1], nums[j]
				sorted = false
			}
		}

		if sorted {
			break
		}
	}

	return nums
}
```



### 选择排序

- 思路：每一轮选取未排定的部分中**最小**的部分交换到未排定部分的最开头，经过若干个步骤，就能排定整个数组。即：先选出最小的，再选出第 2 小的，以此类推。
- 优点：交换次数最少。

```go
func selectSort(nums []int) []int {
	for i := 0; i < len(nums); i++ {
		minIndex := i

		for j := i + 1; j < len(nums); j++ {
			// 找到更小的元素和下标
			if nums[j] < nums[minIndex] {
				minIndex = j
			}
		}

		nums[i],nums[minIndex] = nums[minIndex], nums[i]
	}

	return nums
}

```



### 插入排序

- 思路：每次将一个数字插入一个有序的数组里，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。

```go

// 插入排序
func insertSort(nums []int) []int {

	for i := 1; i < len(nums); i++ {
		// 先暂存这个元素，然后之前元素逐个后移，留出空位
		temp := nums[i]

		j := i

		for j > 0 && nums[j - 1] > temp {
			nums[j] = nums[j - 1]
			j--
		}
		nums[j] = temp
	}

	return nums
}

```





### 桶排序

- 将n个数据划分成m个桶，每个桶只放固定范围的数据，对桶内元素排好序之后，整体也就有序了。

- 适用场景：数据分布比较均匀的场景。



### 计数排序

- 把每个出现的数值都做一个计数，然后根据计数从小到大输出得到有序数组。
- 适用场景：数据范围不大的非负整数的场景。高考总分数的统计排名。



### 基数排序

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。
- 使用场景：
- 时间复杂度：O(k*n)，k是数据长度，较小时计为：O(n)



### 基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值；