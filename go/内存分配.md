### 内存分配

#### 设计原理

#### 管理组件

#### 内存分配

#### 相关知识点

- 内存逃逸
- 内存对齐

#### 疑问点

- 内存分配如何减少竞争带来的性能损耗

# 内存对齐

## Q:为什么要内存对齐

### 平台移植性

不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况

### 性能

若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作，这显然高效很多，是标准的空间换时间做法

## Q:特殊变量zerobase

空结构体是没有内存大小的结构体。但有一个`zerobase`变量作为特殊起点，占用8个字节。

`runtime.mallocgc`方法对分配大小为0的变量会直接返回`zerobase`。

## 字段中包含空结构体

### 空结构体在前面-不占空间

```go
// Object1 类型变量占用 1 个字节
type Object1 struct {
	s struct {}
	b byte
}

// Object2 类型变量占用 8 个字节
type Object2 struct {
	s struct {}
	n int64
}

o1 := Object1{ }
o2 := Object2{ }
	
```

### struct{}在中间-不分配空间

```go
// Object1 类型变量占用 16 个字节
type Object1 struct {
	b  byte
	s  struct{}
	b1 int64
}

o1 := Object1{ }

```

### struct{}在最后

- struct {} 作为最后一个字段，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变。

```go
type Object1 struct {
	b byte
	s struct{}
}

type Object2 struct {
	n int64
	s struct{}
}

type Object3 struct {
	n int16
	m int16
	s struct{}
}

type Object4 struct {
	n  int16
	m  int64
	s  struct{}
}

type Object5 struct {
  m  int64
	n  int16
	s  struct{}
}

o1 := Object1{} // 2字节
o2 := Object2{} // 16字节
o3 := Object3{} // 6字节
o4 := Object4{} // 24字节
o5 := Object5{} // 16字节

```



### 参考

[Golang是否有必要内存对齐](https://ms2008.github.io/2019/08/01/golang-memory-alignment/)

