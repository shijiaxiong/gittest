## Q：GMP 是什么？

### G (goroutine)

- 用户态线程
- main 本身也是一个goroutine
- goroutine执行同步操作时会被，goroutine执行异步操作时会进入休眠状态，带操作完成后再恢复，不占用系统线程。

### M (machine)

- 操作系统线程，最多可以创建10000个线程。最多只会有`GOMAXPROCS`个活跃线程正常运行。
- 当 M 没有工作可做的时候，在它休眠前，会“自旋”地来找工作：检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作。
- M只有绑定P才可以能执行G，当M阻塞，P就会启动新的或者是找空闲M继续执行。

### P (process)

- 处理器数量：由启动时环境变量`$GOMAXPROCS`或者`runtime.GOMAXPROCS()`指定




### 本地运行队列

- 入队待运行的G优先加到当前的P的本地运行队列，M获取待运行的G也会优先从用友的P的本地运行队列获取
- 本地运行队列入队和出队不需要使用线程锁。
- 本地运行队列的数量达到256个时会入队到全局运行队列。
- 本地运行队列的数据结构是环形队列，由256长度的数组和两个序号(head, tail)组成。
- 当M从P的本地运行队列获取G时，如果发现本地队列和全局队列为空会尝试从其他P盗取一半的G过来，这个机制叫做 Work Straling。

### 全局队列

- 全局队列保存在全局变量`sched`中，全局运行队列的入队和出队需要使用线程锁。
- 全局运行队列的数据结构是链表，由两个指针(head,tail)组成。

### 空闲M链表

- M发现无运行的G时会进入休眠，并添加到空闲M链表中，空闲M链表保存在全局变量`sched`。进入休眠的M会等待一个信号量(m.park)，唤醒休眠的M会使用这个信号量。

### 空闲P链表

- 当P的本地运行队列中的所有G都运行完毕，又不能从其他地方拿到G时，拥有P的M会释放P并进入休眠状态，释放的P会变为空闲状态并加到空闲P链表中，空闲P链表保存在全局变量`sched`
- 下次运行的G入队时如果发现有空闲的P,但是又没有自旋中的M时会唤醒或者新建一个M，M会拥有这个P，P会重新变为运行中的状态。



## Q:goroutine和线程的区别

### 内存消耗

- goroutine占用2KB,运行中如果占空间不够用会自动扩容。一个http请求会创建一个goroutine。
- thread需要消耗1MB栈内存。还需要使用`a guard page`的区域和其他thread的栈空间进行隔离。

### 创建销毁

- goroutine由go runtime负责管理，创建和销毁都是用户级别。
- thread创建和销毁是内核操作的，解决办法是线程池。

### 切换

- goroutine切换耗时200ns。只需要保存`gobuf`中的三个寄存器sp、pc和bp。
- thread切换使用1000-1500ns。
- 一个纳秒可以执行12-18条指令。



## Q：系统线程对goroutine的调度本质

- 通过保存和修改CPU寄存器的值来达到切换goroutine的目的。
- 当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。
- 当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。



## Q:go scheduler的初始化

- 初始化g0

- 主线程与m0绑定

- 初始化m0

- 初始化allp



## Q: M是如何找工作的

- `runqget`先从本地队列找
- `globrunqget`定期(调度器调度61次后)从全局队列找。
- 全局队列不存在，随机去别的P偷取(workstealing)一半到本地



## Q:为什么需要 P 这个组件，直接把 G 放到 M 不行吗？

### P的作用：

- **减少全局队列的锁竞争**。每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。
- **提高资源利用率**。P的本地队列为空的时候会从全局或者其他的P本地队列盗取G，减少空转，提高资源利用率。

### 把G直接放到M上

- 当G阻塞的时候就会阻塞M，M阻塞不够用会起更多的M。
- M阻塞就会起新的M，本地队列增多，执行work stealing性能降低。





## Q:G0的作用

- 调度器自旋
- 线程创建的第一个goroutine，创建后不断寻找其他的goroutine来执行
- 创建 `goroutine`、`deferproc` 函数里新建 `_defer`、垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。



## Q:Go的GPM如何调度

- 基于信号的抢占式调度
- 抢占式调度在垃圾回收时触发

- 在函数调用之前，监控线程会去判断G的运行时间如果超过10ms，会被移除运行状态。



## Q

GPM是什么，它们的初始化、状态流转和生命历程。
M 是怎样一步步找工作；
用户栈和 g0 栈的切换；
schedule 的调度循环是怎样运转的；
监控线程做了什么



## Reference

[任务调度源码](https://www.cnblogs.com/zkweb/p/7815600.html)

[go 调度器的实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97)

[调度器GMP原理加示例分析](https://learnku.com/articles/41728)

[调度器的源码解读-关键点，基于1.2源码，缺少基于信号的抢占式调度](https://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&hid=1&sn=8fc2b63f53559bc0cee292ce629c4788&scene=18#wechat_redirect)

[码农桃花源调度器](https://qcrao.com/2019/09/06/dive-into-go-scheduler-source-code/)

