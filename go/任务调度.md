## Q：GMP 是什么？

### G (goroutine)

- 用户态线程
- main 本身也是一个goroutine
- goroutine执行异步操作时会进入休眠状态，带操作完成后再恢复，不占用系统线程

### M (machine)

- 操作系统线程，最多可以创建10000个线程。，做多只会有`GOMAXPROCS`个活跃线程正常运行。

### P (process)

- 处理器数量：由启动时环境变量`$GOMAXPROCS`或者`runtime.GOMAXPROCS()`指定




### 本地运行队列

- 入队待运行的G优先加到当前的P的本地运行队列，M获取待运行的G也会优先从用友的P的本地运行队列获取
- 本地运行队列入队和出队不需要使用线程锁。
- 本地运行队列的数量达到256个时会入队到全局运行队列。
- 本地运行队列的数据结构是环形队列，由256长度的数组和两个序号(head, tail)组成。
- 当M从P的本地运行队列获取G时，如果发现本地队列和全局队列为空会尝试从其他P盗取一半的G过来，这个机制叫做 Work Straling。

### 全局队列

- 全局队列保存在全局变量`sched`中，全局运行队列的入队和出队需要使用线程锁。
- 全局运行队列的数据结构是链表，由两个指针(head,tail)组成。

### 空闲M链表

- M发现无运行的G时会进入休眠，并添加到空闲M链表中，空闲M链表保存在全局变量`sched`。进入休眠的M会等待一个信号量(m.park)，唤醒休眠的M会使用这个信号量。

### 空闲P链表

- 当P的本地运行队列中的所有G都运行完毕，又不能从其他地方拿到G时，拥有P的M会释放P并进入休眠状态，释放的P会变为空闲状态并加到空闲P链表中，空闲P链表保存在全局变量`sched`
- 下次运行的G入队时如果发现有空闲的P,但是又没有自旋中的M时会唤醒或者新建一个M，M会拥有这个P，P会重新变为运行中的状态。



## Q:goroutine和线程的区别

### 内存占用

- goroutine占用2KB,运行中如果占空间不够用会自动扩容。一个http请求会创建一个goroutine。
- thread需要消耗1MB栈内存。还需要使用`a guard page`的区域和其他thread的栈空间进行隔离。

### 创建销毁

- goroutine由go runtime负责管理，创建和销毁都是用户级别。
- thread创建和销毁是内核操作的，解决办法是线程池。

### 切换

- goroutine切换耗时200ns。一个纳秒可以执行12-18条指令。
- thread切换使用1000-1500ns

## Q: M是如何找工作的

- `runqget`先从本地队列找
- `globrunqget`定期(调度器调度61次后)从全局队列找
- 全局队列不存在，随机去别的P偷取(workstealing)一半到本地

## Q:G0的作用

- 调度器自旋
- 线程创建的第一个goroutine，创建后不断寻找其他的goroutine来执行
- 创建 `goroutine`、`deferproc` 函数里新建 `_defer`、垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。



## Q:Go的GPM如何调度

- 基于信号的抢占式调度
- 抢占式调度在垃圾回收时触发



## Q：G的抢占式调度

- 在函数调用之前，监控线程回去判断G的运行时间如果超过10ms，会被移除运行状态。



## Reference

[任务调度源码](https://www.cnblogs.com/zkweb/p/7815600.html)

[go 调度器的实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97)

[调度器GMP原理加示例分析](https://learnku.com/articles/41728)

