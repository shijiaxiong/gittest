## Q：GMP 是什么？

### G (goroutine)

- mian 本身也是一个gotoutine

### M (machine)

- 系统线程

### P (process)

- 处理器数量：由启动时环境变量`$GOMAXPROCS`或者`runtime.GOMAXPROCS()`指定

  

## Q:goroutine和线程的区别

### 内存占用

- goroutine占用2KB,运行中如果占空间不够用会自动扩容。一个http请求会创建一个goroutine。
- thread需要消耗1MB栈内存。还需要使用`a guard page`的区域和其他thread的栈空间进行隔离。

### 创建销毁

- goroutine由go runtime负责管理，创建和销毁都是用户级别。
- thread创建和销毁是内核操作的，解决办法是线程池。

### 切换

- goroutine切换耗时200ns。一个纳秒可以执行12-18条指令。
- thread切换使用1000-1500ns

## Q: M是如何找工作的

- `runqget`先从本地队列找
- `globrunqget`定期(调度器调度61次后)从全局队列找
- 全局队列不存在，随机去别的P偷取(workstealing)一半到本地

## Q:G0的作用

- 调度器自旋
- 线程创建的第一个goroutine，创建后不断寻找其他的goroutine来执行
- 创建 `goroutine`、`deferproc` 函数里新建 `_defer`、垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。



## Q:Go的GPM如何调度

