## 并发编程

- 并发与并行

> 并发：多线程程序在`一个核`的CPU上运行。
>
> 并行：多线程程序在`多个核`的CPU上运行。

- 并发并不是并行

> 并发主要由切换时间片来实现`同时`运行，并行则是直接利用多核实现多线程。

### Goroutine

#### 为什么会goroutine泄露

- 启动一个Goroutine后因为阻塞永远不会关闭或者超时，就会发生泄漏。
- 一个Goroutine至少占用2KB(说至少是因为协程中存在会变量))内存。

#### 如何避免泄漏

- 启动Goroutine后如果希望会终止，调用者要了解Goroutine的什么时候结束。
- 关闭可以使用context的超时、channel通讯去close。
- 使用有缓冲channel 不阻塞协程，有缓冲的channel要记得关闭(待验证)？？？？？

#### 如何排查goroutine泄漏

- pprof

#### References

[Goroutine泄漏-被遗忘的发送者](https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html)

[go中内存泄漏与排查](https://www.cnblogs.com/ricklz/p/11262069.html)

[实战go内存泄漏](https://segmentfault.com/a/1190000019222661)

### Memory Model

#### 内存对齐

##### 什么是内存对齐

现代计算机中内存空间都是按照bytes划分，理论上可以从任何起始地址访问任意类型变量，但实际中在访问特定类型变量时经常在特定的内存地址访问(数据的首地址是某个数K[K为4或者8]的倍数)，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是内存对齐。

##### 为什么要内存对齐

- 不同硬件平台不一定支持访问任意内存地址的数据，使用内存对齐可以保证每次访问都是从块内存地址头部开始存取
- 提高内存访问速度

#### 内存重排

##### 什么是内存重排

内存重排是指程序在实际运行时对内存的访问顺序和代码编写时的顺序不一致，主要是为了提高运行效率。分别是硬件层面的 `CPU重排` 和软件层面的 `编译器重排`。

> CPU重排是对读写指令重排。
>
> 编译器重排会对代码进行优化

##### 为什么要内存重排

- 减少读写等待导致的性能能降低。
- 最大化提高CPU利用率。

#### 内存屏障

##### 什么是内存屏障

使得CPU或编译器在对内存进行操作的时候，严格按照一定的顺序来执行，也就是说在memory barrier之前的指令和memory barrier之后的指令不会由于系统优化等原因而导致乱序。

#### 内存相关References

[内存模型](https://www.findshank.com/2020/05/03/The-Go-Memory-Model/)

[内存重排-码农桃花源](https://qcrao.com/2019/06/17/cch-says-memory-reorder/)

[内存重排-曹大](https://github.com/cch123/golang-notes/blob/master/memory_barrier.md)

### Content

>  context用来解决goroutine之间`退出通知`、`元数据传递`的功能

[深度解密GO语言-context](https://qcrao.com/2019/06/12/dive-into-go-context/)

### Sync

#### Mutex 互斥锁

```go
var x int64
var wg sync.WaitGroup
var lock sync.Mutex

func add() {
    for i := 0; i < 5000; i++ {
        lock.Lock() // 加锁
        x = x + 1
        lock.Unlock() // 解锁
    }
    wg.Done()
}
func main() {
    wg.Add(2)
    go add()
    go add()
    wg.Wait()
    fmt.Println(x)
}
```

#### RWMutex 读写互斥锁

互斥锁是完全互斥的，但是有很多实际的场景下是读多写少的，当我们并发的去读取一个资源不涉及资源修改的时候是没有必要加锁的，这种场景下使用读写锁是更好的一种选择。读写锁在Go语言中使用sync包中的RWMutex类型。

读写锁分为两种：读锁和写锁。当一个goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine获取写锁之后，其他的goroutine无论是获取读锁还是写锁都会等待。

#### WaitGroup

- 32 与 64位的内存对齐

  

### chan

#### 定时器 调度器 网络轮训器 系统监控

> 《go语言设计与实现》中多提到的项