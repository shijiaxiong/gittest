## Q:gin框架选型对比

#### gin框架优点

- 轻量级、高性能、简单易用、支持路由分组。
- 可拓展性好，社区活跃度高。
- 错误管理：默认会使用 `Logger`和`Recovery` 集中收集 HTTP 请求期间发生的错误，并将它们记录日志中。



## Q:路由底层实现

- 底层数据结构是**压缩字典树**。相对于字典树的存储结构，压缩字典树可以减少树的层数，同时因为每个节点上数据存储也比通常的字典树要多，所以程序的局部性较好（一个节点的path加载到cache即可进行多个字符的对比），从而对CPU缓存友好。

#### 路由查找算法(延伸项，不是很完善)

##### 哈希路由查找算法

- 应用：Linux的内核做网关查找使用。
- 局限性：匹配项增多，哈希碰撞也会随着增加，并且其时间复杂性不可控。

#### 树查找算法

- 优势:查询效率稳定

#### reference

[路由表查找算法概述-哈希/LC-Trie树/256-way-mtrie树](https://app.yinxiang.com/shard/s43/nl/13675070/270af794-1ed2-42ed-a7b8-deef3614fe2d)



## Q:中间件的底层实现原理

- **责任链模式：** 为请求创建了一个接收者对象的链，对象链上的每个对象都可以依次对请求进行处理。
- 优点： 将请求的发送者和接受者进行了解耦。

#### Reference

[中间件详解](https://www.flysnow.org/2020/06/28/golang-gin-middleware.html)



## Q:为什么要使用RPC？ RPC和HTTP的区别

- rpc是远端过程调用，其调用协议通常包含：传输协议 和 序列化协议。
- RPC是面向服务的封装。相较于远程调用可以屏蔽远程调用和本地调用的区别，隐藏底层网络通讯的复杂性。
- 功能齐全的rpc库相对http，是封装了`服务发现`，`负载均衡`，`熔断降级`一类面向服务的高级特性。像Java的Dubbo、Maton功能就比较齐全，但是他们在跨语言通讯上做的没有GRPC比较好。



## rpc框架对比

#### 框架选型原则

- 是否跨语言。
- 支持的通信协议。包含http 、二进制、TCP。
- 数据序列化方式。
- 服务治理。
- 注册中心。
- 整体性能。



#### GRPC

- 基于http2.0。提供了连接复用，服务器推送，首部压缩等机制。
- 使用protobuf数据序列化协议(二进制序列化)。压缩传递效率更高。
-  `.protoc` 文件提供了清晰的接口定义。客户端可以通过这个文件生成。使用方便。
- 超时传递：客户端如果ctx中带超时时间，底层的会在请求中加`grpc-timeout`。服务端接收到之后也会解析超时时间。

#### hprose

- 简单高效支持多语言。
