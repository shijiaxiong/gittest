## Q:什么是堆栈？

>  在计算机中堆栈的概念分为：数据结构的堆栈和内存分配中堆栈

### 数据结构中的堆栈

**堆**：可以看成一棵树。

**栈**：一种先进后出的数据结构。

###内存分配中的堆栈

**堆**：一般由程序员分配释放,若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

**栈**： 由操作系统自动分配释放,存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

###堆栈的缓存方式

**堆**：二级缓存，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

**栈**： 一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放。

> 一级缓存可分为一级指令缓存和一级数据缓存。一级指令缓存用于暂时存储并向CPU递送各类运算指令；一级数据缓存用于暂时存储并向CPU递送运算所需数据。
>
> 二级缓存就是一级缓存的缓冲器，存储那些CPU处理时需要用到、一级缓存又无法存储的数据。

## Q:Go中变量是分配在堆上还是栈上

编译器在编译阶段决定变量分配在堆还是栈上。



## Q:go逃逸分析



## Q:goroutine的栈

### goroutine stack多大呢？是固定的还是动态变化的呢?

每个goroutine（g0除外，g0分配64k）在初始化时stack大小都为2KB, 运行过程中会根据不同的场景做动态的调整。

### stack动态变化的话，什么时候扩容和缩容呢？

Go在函数调用前会比较栈指针寄存器SP和栈的可用栈空间进行比较。当检测到栈指针寄存器SP**小于**栈的可用空间会做扩容。检测到当前栈大小不够用，调用morestack进行动态扩容。

扩容：

- 检测到当前栈大小不够用，调用morestack进行动态扩容。

- 保存当前goroutine的上下文。
- 分配一个2倍于当前大小的新栈。
- 旧栈中的内容拷贝到新栈中，函数在新栈中运行。

缩容：

- 函数返回时处理栈缩小的问题。
- 栈的收缩是垃圾回收的过程中实现的。当检测到栈只使用了不到1/4时，栈缩小为原来的1/2。

### 对服务有什么影响吗？如何排查栈扩容缩容带来的问题呢?

栈的扩容会有”中断“并栈拷贝。缩容会存在栈拷贝和写屏障。对内存占用和延时敏感的服务中，可能面临内存占用高、服务不稳定的状况。

## Reference

- [为何说Goroutine的栈空间可以无限大](http://blog.xiayf.cn/2014/01/17/goroutine-stack-infinite/)
- [Goroutine stack-扩缩容对服务的影响](https://studygolang.com/articles/10597)
- [go语言连续栈](https://tiancaiamao.gitbooks.io/go-internals/content/zh/03.5.html)
- [go栈内存管理](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/)

