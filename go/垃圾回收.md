## Q:常见的 GC 实现方式有哪些？Go 语言的 GC 使用的是什么？

- 引用计数式 GC。php为引用计数。
  - 优点：内存的回收分摊到整个程序的运行过程。不需要暂停程序。
  - 缺点：对象的循环引用 会造成内存无法被回收。
- 追踪式。从根对象出发，根据对象之间的引用信息，一步步推进直到扫描完毕整个堆并确定需要保留的对象，从而回收所有可回收的对象。Go、 Java、V8 对 JavaScript 的实现等均为追踪式 GC。

- 分代式：将对象按照生命周期的长度进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。对于新生代区域的扫描频率应该高于老年代区域。



## Q:Go垃圾回收算法

### 1、标记清除

### 2、三色标记法

> 根据指针的bitmap进行扫描.

- 标记类算法会在垃圾回收的时候暂停整个程序(STW)。三色标记法是对标记阶段的改进，使得用户程序和GC的标记程序能够并发标记清除。减少STW时间。
- 带来的问题：并发标记可能清除的过程可能会出现对象丢失的问题。

### 3、混合写屏障技术(仅在堆上执行)

- `GC`开始时将栈上所有对象标记为黑色，无须`STW`
- `GC`期间在栈上创建的新对象均标记为黑色
- 将被删除的下游对象标记为灰色
- 将被添加的下游对象标记为灰色

- go1.8引入原因：
  - 插入写屏障需要对栈上的对象 stw后重新扫描。
  - 删除写屏障存在回收不及时的问题。
  - 混合写屏障减少了STW时间，提高了回收精度。



## Q:什么是根对象

根对象是垃圾回收器在标记过程时最先检查的对象，包括：

- 全局变量：在编译期就能确定的那些存在于程序整个生命周期的变量。
- 执行栈：每个goroutine都包含自己的执行栈，这些执行栈包含**栈上的变量**及指向**分配的堆内存区块的指针**。
- 寄存器：寄存器的值可能标识一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

## Q:三色标记法是什么？

- 白色对象：未搜索的对象，在回收周期开始时所有对象都是白色，在回收周期结束时所有的白色都是垃圾对象
- 灰色对象：正在搜索的对象，但是对象身上还有一个或多个引用没有扫描
- 黑色对象：已搜索完的对象，所有的引用已经被扫描完

三色标记法是对标记清除法的改进，标记清除法在执行过程中要求长时间的STW。

### 具体的实现如下：

> 根据指针的bitmap进行扫描.

- 初始时所有对象都是白色对象
- 从`GC Root`对象出发，扫描所有可达对象并标记为灰色，放入待处理队列
- 从队列取出一个灰色对象并标记为黑色，将其引用对象标记为灰色放入队列
- 重复上一步骤，直到灰色对象队列为空
- 此时所有剩下的白色对象就是垃圾对象



在go内部对象并没有保存颜色的属性, 三色只是对它们的状态的描述,

- 白色的对象在它所在的span的gcmarkBits中对应的bit为0

- 灰色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象在标记队列中,

- 黑色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象已经从标记队列中取出并处理.

gc完成后, gcmarkBits会移动到allocBits然后重新分配一个全部为0的bitmap, 这样黑色的对象就变为了白色.



## Q:并发标记清除法的难点是什么？或者三色标记法的并发性问题。

在并发标记清除的过程中**可能会出现对象丢失**的问题。

如下图：由于并发回收的存在，可能会在回收器对对象图扫描的间隙有赋值器修改对象图。使得某些可访达的子节点被错误回收。(B可能被错误回收)

![gc](/Users/shijiaxiong/web/interview_knowledge/go/static/640.png)



### 并发性问题的原因及解决思路

假设三色标记法和用户程序并发执行，那么下列两个条件**同时满足**就可能出现错误回收非垃圾对象（对象丢失）的问题：

- 条件1：某一黑色对象引用白色对象
- 条件2：对于某个白色对象，所有和它存在可达关系的灰色对象丢失了访问它的可达路径

即：只要存在未经访问的能够到达白色对象的可达路径，就可以令黑色对象引用白色对象，反正该白色对象在后面标记中会被识别为“可达”对象从而不会被错误回收。



一种最简单解决三色标记并发问题的方法是停止所有的赋值器线程，保证标记过程不受干扰，即垃圾回收器中常提到的`STW, stop the world`方法。另外一种思路就是**使用赋值器屏障技术使得赋值器在进行指针写操作时同步垃圾回收器，保证不破坏弱三色不变性**



### 读写屏障技术

使用屏障技术可以使得用户程序和三色标记过程并发执行，我们只需要达成下列任意一种三色不变性：

- **强三色不变性**：黑色对象永远不会指向白色对象。
- **弱三色不变性**：黑色对象指向的白色对象至少包含一条由灰色对象经过白色对象的可达路径。

`GC`中使用的内存读写屏障技术指的是编译器会在编译期间生成一段代码，该代码在运行期间用户读取、创建或更新对象指针时会拦截内存读写操作，相当于一个`hook`调用，根据`hook`时机不同可分为不同的屏障技术。由于读屏障`Read barrier`技术需要在读操作中插入代码片段从而影响用户程序性能，所以一般使用写屏障技术来保证三色标记的稳健性。

>  我们讲内存屏障技术解决了三色标记法的`STW`缺点，并不是指消除了所有的赋值器挂起问题。需要分清楚`STW`方法是全局性的赋值器挂起而内存屏障技术是局部的赋值器挂起。



### 插入写屏障

- 具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)

- 满足: **强三色不变式**. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)
- 插入屏障技术在栈空间的对象操作中不使用，仅在堆空间对象的操作中使用。所以在结束时要对栈重新进行三色标记扫描。但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束。最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.

### 删除写屏障

- 具体操作:被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。
- 满足： **弱三色不变式**. (保护灰色对象到白色对象的路径不会断)



## Q:什么是写屏障、混合写屏障，如何实现？

插入写屏障和删除写屏障的短板：

- 插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；
- 删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

### 混合写屏障：

- `GC`开始时将栈上所有对象标记为黑色，无须`STW`。（在栈上开启写屏障会影响用户程序的性能）
- `GC`期间在栈上创建的新对象均标记为黑色
- 将被删除的下游对象标记为灰色
- 将被添加的下游对象标记为灰色



```go
// 混合写屏障
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot)
    shade(ptr)
    *slot = ptr
}
```



## Q:垃圾回收器的行为

Go垃圾收集器的行为分为两个大阶段Mark(标记)阶段和Sweep(清理)阶段。Mark阶段又分为三个步骤，其中两个阶段会有STW(Stop The World),另一个阶段也会有延迟，从而导致应用程序延迟并降低吞吐量，这三个步骤是：

- Mark Setup 阶段- STW
- Marking阶段- 并发执行
- Mark终止阶段 - STW

### Mark Setup阶段

垃圾收集开始时，必须执行的第一个动作是打开写屏障（Write Barrier）。写屏障的目的是允许垃圾收集器在垃圾收集期间维护堆上的数据完整性，因为垃圾收集器和应用程序将并发执行。

为了打开写屏障，必须停止每个goroutine。此动作通常非常快，平均在10到30微秒之内完成。

### Marking阶段

一旦写屏障打开，垃圾收集器就开始标记阶段。垃圾收集器所做的第一件事是占用25%CPU。垃圾收集器使用Goroutines进行垃圾收集工作。

如果标记阶段有G大量分配内存则会被强制执行协助标记工作。应用程序Goroutine成为Mark Assist（协助标记）中的时间长度与它申请的堆内存成正比。Mark Assist有助于更快地完成垃圾收集。

### Mark终止阶段

最终关闭写屏障，执行各种清理任务，并计算下一个垃圾回收周期的目标。一直处于循环中的goroutine也可能导致stw延长（类似mark setup的情况）。

### 并发清理

标记完成后，下一阶段执行并发清理。清理阶段用于回收标记阶段中标记出来的可回收的内存。当应用程序goroutine尝试在堆内存中分配新内存时，会触发该操作。清理导致的延迟和吞吐量降低被分散到每次内存分配时。



## Q:有了GC为什么还会发生内存泄漏？

- 预期能被快速释放的内存因被根对象引用而没有得到迅速的释放。比如某个变量被附在了全局对象上，可能永远不会被释放。

  ```go
  
  var cache = map[interface{}]interface{}{}
  
  func keepalloc() {
    for i := 0; i < 10000; i++ {
      m := make([]byte, 1<<10)
      cache[i] = m
    }
  }
  ```


- 如果一个程序持续不断地产生新的 goroutine、且不结束已经创建的 goroutine 并复用这部分内存，就会造成内存泄漏的现象。

```go
var ch = make(chan struct{})

func keepalloc3() {
  for i := 0; i < 100000; i++ {
    // 没有接收方，goroutine 会一直阻塞
    go func() { ch <- struct{}{} }()
  }
}
```

[go中内存泄漏与排查](https://www.cnblogs.com/ricklz/p/11262069.html)

[实战go内存泄漏](https://segmentfault.com/a/1190000019222661)



## Q:触发 GC 的时机是什么？

> runtime/mgc.go
>
> `gcTriggerHeap：`当前分配的内存达到一定值就触发GC。
>  `gcTriggerTime：`当超过两分钟没有产生任何 GC 时，强制触发 GC。
>  `gcTriggerCycle：`调用 runtime.GC 来触发 GC。

- **主动触发**

	- 通过调用 runtime.GC 来触发 GC，此调用阻塞式地等待当前 GC 运行完毕。

- **被动触发** ，分为两种方式：
  - 使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。
  - 当前分配的内存达到一定值就触发GC。使用步调（Pacing）算法，其核心思想是控制内存增长的比例。

## Q:如果内存分配速度超过了标记清除的速度怎么办？

当 Goroutine 调用 `runtime.mallocgc`分配新对象时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）和清扫(Sweep)的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。

## Q:GC 调优

- 优化内存申请速度 
  - 例如一下子创建大量goroutine会造成GC压力过大，可以控制g的创建速度去达到这个目的。
- 尽量减少内存的申请
  - 例如：对于字符串频繁的拼接操作，提前申请足够长度的字符串。而不要用+
- 复用已经申请的内存
  - sync.pool





## Reference

[GO GC 20问](https://mp.weixin.qq.com/s/o2oMMh0PF5ZSoYD0XOBY2Q)

[GO GC实现 源码分析](https://www.cnblogs.com/zkweb/p/7880099.html)

[GC 译文 垃圾收器的全局深入理解](https://app.yinxiang.com/shard/s43/nl/13675070/11ff302e-5f84-497c-a64d-eb27b3725737)

[垃圾回收机制的理解](https://app.yinxiang.com/shard/s43/nl/13675070/fe9de264-95a5-4fcb-b183-79fe665bff01)

