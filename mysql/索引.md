##  Q:为什么Mysql索引要用B+树不是B树？

- 同样的查询B+树IO更少、查询效率稳定：用B+树不用B树考虑的是**IO对性能的影响**，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。
- 支持范围查询：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。

#### 面试官：为何不采用Hash方式？

因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。

哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。

### 哪些情况需要创建索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段
3. 查询中与其他表关联的字段，外键关系建立索引
4. 单键/组合索引的选择问题，高并发下倾向创建组合索引
5. 查询中排序的字段，排序字段通过索引访问大幅提高排序速度
6. 查询中统计或分组字段

### 哪些情况不要创建索引

1. 表记录太少
2. 经常增删改的表
3. 数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）
4. 频繁更新的字段不适合创建索引（会加重IO负担）
5. where条件里用不到的字段不创建索引

### MySQL高效索引

**覆盖索引**（Covering Index）,或者叫索引覆盖，即从辅助索引中就可以查询的记录，不需要回表操作

- 就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说**查询列要被所建的索引覆盖**。

- 对于某些where条件是辅助索引中字段的统计问题，存储引擎不会通过查询聚集索引来进行统计。如(a,b)的联合索引，一般是不可以选择列b中所谓的查询条件。但是如果是统计操作，并且是覆盖索引的，则优化器会进行选择。

- **判断标准**

  使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为**using index**，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询

### 索引中的Cardinality

- `cardinality`表示索引中不重复记录数量的预估值。

- 表中的`cardinality`应尽可能接近1，优化器会根据这个值判断是否使用这个索引。
- `cardinality`使用采样统计每次得到的值可能不同。InnoDB引擎对cardinality更新策略：1、表中1/16的数据已经发生了变化。2、stat_modified_counter>2 000 000 000



## Q:InnoDB中一棵B+树能存多少行数据？

叶子节点记录的数据
	页大小 16k,一行1k，那么一页可以存16行
非叶子节点
	主键ID bigint 8字节，指针6字节，一页(16k)可以存储 16384/14 = 1170

三层树高



## Q:MySQL中 in和 exists 的区别？

如果查询的两个表大小相当，那么用in和exists差别不大。

如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in



## Q:Mysql中null和not null字段区别

- 空间占用：
  - 空值不占用空间，null值会占用空间。
  - 在InnoDB的compact模式下，null值会占用额外的存储空间。
- 索引使用：
  - 在InnoDB中NULL值被认为是最小值，值为NULL的二级索引记录会被存储在B+树的最左边。并且会对每行数据都做记录。
- 数据查询：
  - count()统计某列的记录数的时候，如果采用NULL值，系统会自动忽略掉，但是空值是会被统计到的。
  - 查找not null字段不为空的数据，使用`select * from test where col1 <> ''`。

### 在列中应该设置为null 还是not null?

- 可为NULL的列**使得索引、索引统计和值比较都更复杂**。

- 可为NULL的列会**使用更多的存储空间**，在MySQL中也需要特殊处理。
- 对于InNoDB存储引擎，很多值为NULL，只有少数列有非NULL值的情况会有很好的空间效率。但是不适用于MyISAM。



### Reference

[mysql 中null 、not null的存储](https://app.yinxiang.com/shard/s43/nl/13675070/ba2d8234-3f57-460b-a60c-5dd0a559881e)



## Q:Mysql只走一个索引，还是会索引合并？索引下推会怎么样？

- MySQL 每次可以使用多个索引，即 index merge，但大多数情况下出于查询效率的考虑只会使用一个索引。
- **当查询语句中有多个索引条件时，索引优化器会根据查询效率选择使用一个索引还是进行索引合并。**

### index merge是什么？

- 在5.0版本之后，对一个表可以使用多个索引分别进行条件扫描(不支持跨表扫描)，然后对这些索引取交集，并集，或者先取交集再取并集。从而减少从数据表中取数据的次数，提高查询效率。
- 使用explain对sql语句进行分析时，如果使用了索引合并，type字段会显示index_merge。

### 为甚么很少见索引合并？

- 如果分析两个索引二叉树，比只使用一个索引的速度比起来更慢，则索引优化器就只会使用一个索引。


###### 优化器选择索引的判断标准

- 扫描行数。扫描行数是一个采样统计的估计值。
- 是否使用临时表。
- 是否排序。

### 索引下推会怎么样？

- 索引下推是在msyql 5.6版本上推出的。由存储引擎多进行一次判断，符合索引条件时才会将数据检索出来返回给MySQL服务器 。
- 开启 ICP(索引下推)，查看执行计划时，Extra 字段会有`Using index condition`说明，表示 ICP 生效，减少了回表数据。这会改善 IO 操作数，提升处理效率。

[msyql 索引下推 是什么和注意事项](https://app.yinxiang.com/shard/s43/nl/13675070/06da35b6-c2a2-4beb-be16-a99a59c7d8be)

