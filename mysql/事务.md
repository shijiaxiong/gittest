## Q:衡量事务的四个特性，ACID是什么

- A（Atomicity）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，事务是不可分割的。实现主要基于undo log。
- C（Consistency）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
- I（Isolation）隔离性：并发执行的各个事务之间不能互相干扰。InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）。
- D（Durability）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。实现主要基于redo log。



## Q:什么是脏读、幻读、不可重复读？并发事务带来的问题。

- 脏读：读取了另一个事务未提交的数据，针对的是某一行的数据。

- 不可重复度：针对`update`操作。前后多次读取，数据内容不一致。**解决：**使用行级锁，锁定该行，同一时间只能一个事务读取该行。

- 幻读：针对`insert、delete`操作。前后多次读取，数据的总量不一致，有数据无故增加和减少。**解决：**使用表锁。

  

## Q:事务的隔离级别

> 数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题。（对勾表示会产生对应的现象）

![](./picture/j0gc9gmx2e.png)

- 读未提交（ Read uncommitted）：一个事务还没有提交时，它做的变更就能被别的事务看到。

- 读已提交（Read committed）：一个事务提交之后它做的变更才会被其他事务看到。

- 可重复读（Repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。可能会发送幻读。

- 读串行化（Serializable）：出现读写锁冲突，后访问的事务必须等前一个事务执行完成。



## Q:MVCC（多版本并发控制）是如何实现的

> mysql的innodb采用了MVCC（多版本并发控制）来实现可重复读。主要通过行数据的隐藏列、基于undo log的版本链、ReadView(一致性视图)实现。

- 在InnoDB存储引擎中，它的聚簇索引包含两个必要的隐藏列，事务当前版本的 **row trx_id** 和 指向undo log的回滚指针 **roll_pointer ** 。
- 每次对行数据的改动，会将原记录放入 `undo log` 中，并通过隐藏的回滚指针指向 undo log 中的原记录。通过回滚指针可以将这条记录的所有`undo log`连接起来，构成版本链。 版本链的头结点就是当前记录的最新值。
- InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。
- 被访问的版本的 trx_id ，只有满足 小于高水位，且不在未提交事务合集中的版本才能访问。
  - 读已提交在每次读取数据前都生成一个ReadView.
  - 可重复读在第一次读取数据时生成一个ReadView.

![](./picture/WX20210510-230144@2x.png)



## Q：什么是当前读和快照读？

#### 当前读

- 当前读, 读取的是最新版本, 会对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。
- 当前读的方式： `select ... lock in share mode`(共享读锁)、 `select ... for update`、`update`、`delete`、`insert`。
- **实现方式：** next-key锁(行记录锁+Gap间隙锁)

#### 快照读

- 快照读，读取的是记录的可见版本。不需要加锁。

- **实现方式：** undo log和mvcc。



## Q:MySQL如何解决幻读问题？

- 快照读(MVCC)：将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。
- 当前读(next-key lock)：锁住当前记录，以及左右两个区间的间隙。

#### MySQL的可重复读(RR)隔离级别下 真的不会产生幻读吗？





## Q:Mysql 中事务是如何实现的

### redo log

- 重做日志，用来实现**事务的持久性**。日志由重做日志缓冲区（redo log buffer）和重做日志文件（redo log file）,前者是在内存中，后者是在磁盘中。
- redo log作用：把随机IO变成了顺序IO，也就是WAL（write ahead log）技术。因为如果每次的数据更新(包含未提交事务)都写入磁盘，那么磁盘需要先找到数据再更新，整个过程IO、查询成本很高。

#### 引入原因

- Innodb为了提高数据的读写效率，引入了Buffer Poll作为数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。
- Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

#### 引入之后的操作

当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改**先写入日志，再更新到Buffer Pool**，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

#### redo log 与bin log的区别

- 作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响事务持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。
- 层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。
- 内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。

#### binlog为什么没有crash_safe的能力

当数据库 crash 后，想要恢复**未刷盘但已经写入 redo log 和 binlog 的数据**到内存时，binlog 是无法恢复的。

虽然 binlog 拥有全量的日志，但**没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有**。

### undo log

- undo log是用来回滚数据的用于保障 未提交事务的原子性

## Reference

[Innodb中事务隔离级别和锁的关系](https://app.yinxiang.com/shard/s43/nl/13675070/a39e2dcc-4280-4017-9ef4-1457ff182c21)

[事务隔离级别和实现原理](https://app.yinxiang.com/shard/s43/nl/13675070/95fa2250-bf74-4d1c-b1bd-465ebfafe1e8)



[Innodb 的redo log 、bin log作用](https://app.yinxiang.com/shard/s43/nl/13675070/b3ce3b2b-1f83-4dd0-9d74-1500cb1c7ac6)

