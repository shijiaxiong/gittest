## Q:进程、线程、协程的区别

#### 进程

- 进程是操作系统资源分配的最小单位，是程序实体。进程拥有独立的内存地址空间。
- 一个进程有多个线程。

#### 线程

- 线程是CPU调度和执行的最小单元。
- 多个线程共享同一进程内的资源。

#### 协程

- 用户态线程。创建、回收、调度由用户态程序去控制，go由runtime控制。



#### 进程和线程的区别

- **地址空间：** 
  - 进程拥有独立的内存地址空间。
  - 线程共享进程占有的内存空间和资源。
- **通信方式：**
  - 进程中通信代价比线程间高。有管道(Pipe)、命名管道(FIFO)、消息队列、信号量 、共享内存、套接字（Socket）。
  - 线程间通信主要用于线程同步。有互斥锁，读写锁，自旋锁，信号量，条件变量和屏障。

- **可靠性**：
  - 进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；
  - 一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
- **开销**：
  - 进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大。
  - 线程只需要保存寄存器和栈信息，开销较小。



#### 线程和协程的区别

- **资源占用：**
  - goroutine占用2KB,运行中如果占空间不够用会自动扩容。一个http请求会创建一个goroutine。
  - thread需要消耗1MB栈内存。还需要使用`a guard page`的区域和其他thread的栈空间进行隔离。

- **开销：**
  - goroutine由go runtime负责管理，创建和销毁都是用户级别。切换上下文速度更快。goroutine切换耗时200ns。
  - thread创建和销毁是内核操作的，解决办法是线程池。thread切换使用1000-1500ns。
  - 一个纳秒可以执行12-18条指令。



## Q:线程的调度方式？

单核CPU

- 非抢占式的**先来先服务（First Come First Severd, FCFS）算法** ：每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。
  - 当一个长作业在运行，那么后面的短作业等待的时间就会很长。
  - 对长作业有利，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统。
- **最短作业优先（Shortest Job First, SJF）：** 优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。
- **高响应比优先 （Highest Response Ratio Next, HRRN）调度算法**：每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：`优先权=（等待时间+要求服务时间）/要求服务时间`。
- **时间片轮转调度算法(可抢占的)**：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
- **最高优先级（Highest Priority First，HPF）调度算法:**进程的优先级可以分为，静态优先级或动态优先级：
  - 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
  - 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是**随着时间的推移增加等待进程的优先级**。
- **多级队列调度算法**：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
- **多级反馈队列调度算法**：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。
