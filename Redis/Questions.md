## Q:redis 和 memcached 有啥区别？

- 数据结构：redis 相比 memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。
- 原生集群：在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

## Q:Redis性能为什么这么高？

- 纯**内存**操作。
- **单线程**反而避免了多线程上下文切换的开销，避免了锁竞争而导致的性能损耗。
- 核心是基于**非阻塞的IO多路复用**。
  - **是什么**：I/O多路复用 技术通过把**多个I/O的阻塞复用到同一个selct的阻塞上**，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的 多线程/多进程 模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。
  - `select/poll` 每次调用都会线性扫描全部的集合，导致效率呈现线性下降。
  - **Epoll性能提升在哪里：**在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的，那么，只有“活跃”的 socket 才会主动的去调用 callback 函数，其他 idle 状态 socket 则不会。



## Q:Redis为什么要用单线程？

- Redis是基于内存的操作，读取数据很快，不需要在某个线程读取数据时，切换到另一个线程来执行来提高CPU利用率，所以**CPU不会成为瓶颈**所在，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。
- Redis处理网络请求是单线程模型，并通过IO多路复用来提高并发。单在其他模块，比如持久化，会使用多线程。
- 在Redis6.0中采用多个IO线程来处理网络请求，对于读写命令，Redis依然使用单线程来处理。



## Q:Redis的基本数据类型？

- string、list、hash、set、sorted sets

### 有序集合底层数据结构

- 压缩表`zaplsit`，是一个特殊编码的双向链表，它的使用条件是：
  - 元素数量少于128个。
  - 所有member的长度少于64字节。
- 跳表`skiplist`，用跳表的理由：
  - 内存占用上，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个平均每个节点包含1.33个指针，比平衡树更有优势。
  - 范围查询、数据的插入和删除操作简单迅速。

### Reference

[Redis为什么用跳表而不用平衡树？](https://app.yinxiang.com/shard/s43/nl/13675070/fad53dc3-be67-4914-a2df-7e2e1b3f8f6d)



## Q:持久化

### RDB

- 进程中的数据生成快照保存到硬盘
- 启动时可以读取快照文件恢复数据
- 一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟的数据。
- RDB 每次在 `fork` 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

### AOF
- AOF是将Redis执行的命令记录到日志文件中
- 实时性更好，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 `fsync` 操作，最多丢失 1 秒钟的数据。
- 文件过大的时候会触发AOF的重写，通过对过期数据、无效命令、命令合并的方式压缩文件。
- AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低

### Reference

[Reids持久化](https://www.cnblogs.com/kismetv/p/9137897.html)



## Q:Redis数据淘汰机制

### 对象过期策略

Redis回收过期对象的策略：定期删除+惰性删除

- **惰性删除**：在访问key时，如果发现key已经过期，那么会将key删除。
- **定期删除**：Redis会定期随机抽取设置过期时间的key，主动淘汰一批已过期的key。

### 内存不够时清理

- 第一类 不处理，等报错(默认的配置)

  - noeviction，发现内存不够时，不删除key，执行写入命令时发现内存不够直接返回错误信息。（Redis默认的配置就是noeviction）

- 第二类 从所有结果集中的key中挑选，进行淘汰(随机，lru，lfu三种)

  - allkeys-random 就是从所有的key中**随机**挑选key，进行淘汰
  - allkeys-lru 就是从所有的key中挑选**最近使用时间距离现在最远**的key，进行淘汰
  - allkeys-lfu 就是从所有的key中挑选**使用频率最低**的key，进行淘汰。（这是Redis 4.0版本后新增的策略）

- 第三类 从设置了过期时间的key中挑选，进行淘汰(随机，lru，ttl，lfu)

  这种就是从设置了expires过期时间的结果集中选出一部分key淘汰，挑选的算法有：

  - volatile-random 从设置了过期时间的结果集中**随机**挑选key删除。
  - volatile-lru 从设置了过期时间的结果集中挑选**上次使用时间距离现在最久**的key开始删除
  - volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些**快要过期**的key中先删除)
  - volatile-lfu 从过期时间的结果集中选择使用**频率最低**的key开始删除（这是Redis 4.0版本后新增的策略）

## Q:Redis主从架构

单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑**读高并发**的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的**读请求全部走从节点**。这样也可以很轻松实现水平扩容，**支撑读高并发**。

### 主从复制原理：

- `slave node`初次连接到`master node`会触发全量复制（无法进行部分复制也会使用全量复制）。

- 主节点开启后台线程，生成RDB快照，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。

  RDB` 文件生成完毕后， master 会将这个 `RDB` 发送给 slave，slave 会先**写入本地磁盘，然后再从本地磁盘加载到内存**中。

-  master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。

- slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。

### 心跳检测

主从节点互相都会发送 heartbeat 信息。

master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。

###  过期key处理
- slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。



## Q:哨兵

### 主要功能

- **集群监控**：负责监控 redis master 和 slave 进程是否正常工作。
- **故障转移**：如果 master node 挂掉了，会自动转移到 slave node 上。
- 消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

### 哨兵核心知识

- 哨兵至少需要 3 个实例，来保证自己的健壮性。
- 哨兵 + redis 主从的部署架构，是**不保证数据零丢失**的，只能保证 redis 集群的**高可用**性。
- 对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。

### 脑裂问题

- **原因**：脑裂，也就是说，某个 master 所在机器突然**脱离了正常的网络**，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会**认为** master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，集群里就会有两个 master ，也就是所谓的**脑裂**。

- **影响：**虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。
- **解决方案：**要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒。如果说一旦所有的 slave，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，master 就不会再接收任何请求了。

### 宕机的监控

- sdown 是主观宕机，就一个哨兵如果自己觉得一个 master 宕机了，那么就是主观宕机。
- odown 是客观宕机，如果 quorum 数量的哨兵都觉得一个 master 宕机了，那么就是客观宕机。

### slave->master的选举算法

如果一个 master 被认为 odown 了，而且 majority 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作。

如果一个 slave 跟 master 断开连接的时间已经超过了 `down-after-milliseconds` 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。

接下来会对 slave 进行排序：

- 按照 slave 优先级进行排序，slave priority（配置文件中设置） 越低，优先级就越高。
- 如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。
- 如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。

### 领导者哨兵的选举

- Raft算法：监视主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。选举的具体过程这里不做详细描述，一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。

### Reference

[Redis 哨兵集群实现的高可用](https://app.yinxiang.com/shard/s43/nl/13675070/c66ba4de-37fe-4193-a398-df1e6079c280)



## Q:数据分区算法

> 算法主要解决的是数据分区问题

### 哈希取余

- 计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。
- **缺点：**当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。

### 一致性哈希

- 将整个哈希值空间组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1；对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。
- **缺点：**当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。

### 带虚拟节点的一致性哈希分区

- 在一致性哈希分区的基础上，引入了虚拟节点的概念。**Redis集群中的虚拟节点称为槽**。引入槽以后，数据的映射关系由数据hash->实际节点，变成了数据**hash->槽->实际节点**。
- 在使用了槽的一致性哈希分区中，槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小。
- 槽的数量一般远小于2^32，远大于实际节点的数量；在Redis集群中，槽的数量为16384，使用的算法是CRC16。

### 节点间通信机制

- 两个端口

  - 普通端口：为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。
  - 集群端口：端口号是普通端口+10000（10000是固定值，无法改变），集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信。
- Gossip协议
  - 在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。
  - 优点：有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等。
  - 缺点：主要是集群的收敛速度慢。

- Gossip协议类型

  > 集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作

  - meet：某个节点收到客户端的CLUSTER MEET命令时，发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。
  - ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。
  - pong：返回 ping 和 meeet，包含自己的状态和其它信息，也用于信息广播和更新。
  - fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机了。

### 高可用与主备切换

#### 集群伸缩

- Redis集群可以在不影响对外服务的情况下实现伸缩；**伸缩的核心是槽迁移：修改槽与节点的对应关系，实现槽(即数据)在节点之间的移动**
- 在迁移过程中，如果客户端向正在迁移的源节点发送命令，会收到ASK错误。

#### 判断节点宕机

- 如果一个节点认为另外一个节点宕机，那么就是 `pfail`，**主观宕机**。如果多个节点都认为另外一个节点宕机了，那么就是 `fail`，**客观宕机**。
- 在 `cluster-node-timeout` 内，某个节点一直没有返回 `pong`，那么就被认为 `pfail`。
- 如果一个节点认为某个节点 `pfail` 了，那么会在 `gossip ping` 消息中，`ping` 给其他节点，如果**超过半数**的节点都认为 `pfail` 了，那么就会变成 `fail`。

- FAIL 状态是单向的，只能从 PFAIL 升级为 FAIL ，当节点重新可达时，可清除 FAIL 标记。




## Q:缓存雪崩如何解决

**缓存雪崩**是指短时间内大量key失效，导致所有请求全部转向数据库，导致数据库压力过大。

**解决方案**

- 在给缓存设置失效时间时加一个随机值，避免集体失效。
- 双缓存，本地缓存 + redis缓存。

##### 缓存雪崩的事前事中事后的解决方案如下。

- 事前：redis 高可用，主从+哨兵，redis cluster，缓存设置随机过期时间避免全盘崩溃。
- 事中：本地内存缓存(Java有ehcache缓存) + 限流&降级，避免 MySQL 被打死。
- 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。



## Q:缓存穿透如何解决

Redis 缓存穿透指的是攻击者故意大量请求一些Redis缓存中不存在key的数据，导致请 求打到数据库上，导致数据库压力过大。

**解决方案**

1. 做好参数校验，无效的请求直接返回，只能避免一部分情况，攻击者总是可以找到一些没有覆盖的情况。
2. 对缓存中找不到的key，需要去数据库查找的key，缓存到Redis中，但是可能会导致Redis中缓存大量无效的key，可以设置一个很短的过期时间，例如1分钟。
3. 也可以使用布隆过滤器，将所有可能的存在的数据通过去hash值的方式存入到一个足够大的bitmap中去，处理请求时，通过在bitmap中查找，可以将不存在的数据拦截掉。



## Q:缓存击穿如何解决

缓存击穿主要指的是某个热点key失效，导致大量请求全部转向数据库，导致数据库压力过大。

**解决方案**

1. 对热点key设置永不过期。
2. 加互斥锁，缓存中没有热点key对应的数据时，等待100ms，由获得锁的线程去读取数据库然后设置缓存。



## Q:解决缓存与数据库一致性问题？

> 分析缓存与数据库一致性问题需要考虑业务中具体的 读写 规模。

严格`数据库+缓存`一致性方案：

- 读写分离：读请求只访问缓存，写请求修改数据库和缓存
- **读请求和写请求串行化**，串行到一个**内存队列**中去。



### 常用的缓存更新策略

#### Cache Aside Pattern

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

缺点：在更新数据库成功，删除缓存失败的情况下，数据会造成不一致。

缺点解决思路：**先删除缓存，再更新数据库**。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

### Reference

[如何保证数据库与缓存一致性](https://app.yinxiang.com/shard/s43/nl/13675070/f4ee0e90-4458-4a79-8c88-137c740c799b)

[石彬 双写一致方案](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-consistence.md)




### 事务

#### Redis事务的三个阶段

1. 事务开始 MULTI
2. 命令入队
3. 事务执行 EXEC

事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

#### Redis事务相关命令

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行。

1. **redis 不支持回滚**，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2. **如果在一个事务中的命令出现错误，那么所有的命令都不会执行**；
3. **如果在一个事务中出现运行错误，那么正确的命令会被执行**。

- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
- MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
- EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
- 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
- UNWATCH命令可以取消watch对所有key的监控。

#### Redis事务保证原子性吗，支持回滚吗

Redis中，单条命令是原子性执行的，但**事务不保证原子性，且没有回滚**。事务中任意命令执行失败，其余的命令仍会被执行。

### 集群方案

#### Redis哈希槽概念

Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 16K），也就是说使用2k的空间创建了16k的槽数。

详解：[为什么Redis集群有16384个槽](https://www.cnblogs.com/rjzheng/p/11430592.html)

#### Redis集群最大节点个数是多少

16384



### 其他问题

[Redis面试题](https://cloud.tencent.com/developer/article/1612347)

#### Redis与Memcached的区别

[redis和memcached的区别](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-single-thread-model.md)

#### 如何保证缓存与数据库双写时的数据一致性？

[如何保证数据库与缓存的双写一致](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-consistence.md)

#### 布隆过滤器

##### 简介

布隆过滤器（Bloom Filter）是一个基于hash的概率性的数据结构，它实际上是一个很长的二进制向量，可以检查一个元素可能存在集合中，和一定不存在集合中。它的优点是空间效率高，但是有一定false positive(元素不在集合中，但是布隆过滤器显示在集合中)。

##### 原理

布隆过滤器就是一个长度为`m`个bit的bit数组，初始的时候每个bit都是0，另外还有`k`个hash函数。

当加入一个元素时，先用`k`个hash函数得到`k`个hash值，将`k`个hash值与bit数组长度取模得到个`k`个位置，将这`k`个位置对应的bit置位1。

参数设置参考

[白话布隆过滤器](https://blog.huoding.com/2020/06/22/825)

##### 实现

hash函数的选择，murmur3、FNV

[Redis实现布隆过滤器](https://learnku.com/articles/46442)