## Q:redis 和 memcached 有啥区别？

- 数据结构：redis 相比 memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。
- 原生集群：在 redis3.x 版本中，便能支持 cluster 模式，而 memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。

## Q:Redis性能为什么这么高？

- 纯**内存**操作。
- **单线程**反而避免了多线程上下文切换的开销，避免了锁竞争而导致的性能损耗。
- 核心是基于**非阻塞的IO多路复用**。
  - **是什么**：I/O多路复用 技术通过把**多个I/O的阻塞复用到同一个selct的阻塞上**，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的 多线程/多进程 模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。
  - `select/poll` 每次调用都会线性扫描全部的集合，导致效率呈现线性下降。
  - **Epoll性能提升在哪里：**在内核实现中 epoll 是根据每个 fd 上面的 callback 函数实现的，那么，只有“活跃”的 socket 才会主动的去调用 callback 函数，其他 idle 状态 socket 则不会。



## Q:Redis为什么要用单线程？

- Redis是基于内存的操作，读取数据很快，不需要在某个线程读取数据时，切换到另一个线程来执行来提高CPU利用率，所以**CPU不会成为瓶颈**所在，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。
- Redis处理网络请求是单线程模型，并通过IO多路复用来提高并发。单在其他模块，比如持久化，会使用多线程。
- 在Redis6.0中采用多个IO线程来处理网络请求，对于读写命令，Redis依然使用单线程来处理。



## Q:Redis的基本数据类型？

- string、list、hash、set、sorted sets

### 有序集合底层数据结构

- 压缩表`zaplsit`，是一个特殊编码的双向链表，它的使用条件是：
  - 元素数量少于128个。
  - 所有member的长度少于64字节。
- 跳表`skiplist`，用跳表的理由：
  - 内存占用上，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个平均每个节点包含1.33个指针，比平衡树更有优势。
  - 范围查询、数据的插入和删除操作简单迅速。

### Reference

[Redis为什么用跳表而不用平衡树？](https://app.yinxiang.com/shard/s43/nl/13675070/fad53dc3-be67-4914-a2df-7e2e1b3f8f6d)



## Q:持久化

### RDB

- 进程中的数据生成快照保存到硬盘
- 启动时可以读取快照文件恢复数据
- 一般来说，RDB 数据快照文件，都是每隔 5 分钟，或者更长时间生成一次，这个时候就得接受一旦 Redis 进程宕机，那么会丢失最近 5 分钟的数据。
- RDB 每次在 `fork` 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。

### AOF
- AOF是将Redis执行的命令记录到日志文件中
- 实时性更好，一般 AOF 会每隔 1 秒，通过一个后台线程执行一次 `fsync` 操作，最多丢失 1 秒钟的数据。
- 文件过大的时候会触发AOF的重写，通过对过期数据、无效命令、命令合并的方式压缩文件。
- AOF 开启后，支持的写 QPS 会比 RDB 支持的写 QPS 低

### Reference

[Reids持久化](https://www.cnblogs.com/kismetv/p/9137897.html)



## Q:Redis数据淘汰机制

### 对象过期策略

Redis回收过期对象的策略：定期删除+惰性删除

- **惰性删除**：在访问key时，如果发现key已经过期，那么会将key删除。
- **定期删除**：Redis会定期随机抽取设置过期时间的key，主动淘汰一批已过期的key。

### 内存不够时清理

- 第一类 不处理，等报错(默认的配置)

  - noeviction，发现内存不够时，不删除key，执行写入命令时发现内存不够直接返回错误信息。（Redis默认的配置就是noeviction）

- 第二类 从所有结果集中的key中挑选，进行淘汰(随机，lru，lfu三种)

  - allkeys-random 就是从所有的key中**随机**挑选key，进行淘汰
  - allkeys-lru 就是从所有的key中挑选**最近使用时间距离现在最远**的key，进行淘汰
  - allkeys-lfu 就是从所有的key中挑选**使用频率最低**的key，进行淘汰。（这是Redis 4.0版本后新增的策略）

- 第三类 从设置了过期时间的key中挑选，进行淘汰(随机，lru，ttl，lfu)

  这种就是从设置了expires过期时间的结果集中选出一部分key淘汰，挑选的算法有：

  - volatile-random 从设置了过期时间的结果集中**随机**挑选key删除。
  - volatile-lru 从设置了过期时间的结果集中挑选**上次使用时间距离现在最久**的key开始删除
  - volatile-ttl 从设置了过期时间的结果集中挑选可存活时间最短的key开始删除(也就是从哪些**快要过期**的key中先删除)
  - volatile-lfu 从过期时间的结果集中选择使用**频率最低**的key开始删除（这是Redis 4.0版本后新增的策略）

## Q:Redis主从架构

单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑**读高并发**的。因此架构做成主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。所有的**读请求全部走从节点**。这样也可以很轻松实现水平扩容，**支撑读高并发**。

### 主从复制原理：

- `slave node`初次连接到`master node`会触发全量复制（无法进行部分复制也会使用全量复制）。

- 主节点开启后台线程，生成RDB快照，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。

  RDB` 文件生成完毕后， master 会将这个 `RDB` 发送给 slave，slave 会先**写入本地磁盘，然后再从本地磁盘加载到内存**中。

-  master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。

- slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。

### 心跳检测

主从节点互相都会发送 heartbeat 信息。

master 默认每隔 10秒 发送一次 heartbeat，slave node 每隔 1秒 发送一个 heartbeat。

###  过期key处理
- slave 不会过期 key，只会等待 master 过期 key。如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。






### 缓存异常

## Q:缓存雪崩如何解决

**缓存雪崩**是指短时间内大量key失效，导致所有请求全部转向数据库，导致数据库压力过大。

**解决方案**

- 在给缓存设置失效时间时加一个随机值，避免集体失效。
- 双缓存，本地缓存 + redis缓存。

##### 缓存雪崩的事前事中事后的解决方案如下。

- 事前：redis 高可用，主从+哨兵，redis cluster，缓存设置随机过期时间避免全盘崩溃。
- 事中：本地内存缓存(Java有ehcache缓存) + 限流&降级，避免 MySQL 被打死。
- 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。



## Q:缓存穿透如何解决

Redis 缓存穿透指的是攻击者故意大量请求一些Redis缓存中不存在key的数据，导致请 求打到数据库上，导致数据库压力过大。

**解决方案**

1. 做好参数校验，无效的请求直接返回，只能避免一部分情况，攻击者总是可以找到一些没有覆盖的情况。
2. 对缓存中找不到的key，需要去数据库查找的key，缓存到Redis中，但是可能会导致Redis中缓存大量无效的key，可以设置一个很短的过期时间，例如1分钟。
3. 也可以使用布隆过滤器，将所有可能的存在的数据通过去hash值的方式存入到一个足够大的bitmap中去，处理请求时，通过在bitmap中查找，可以将不存在的数据拦截掉。



## Q:缓存击穿如何解决

缓存击穿主要指的是某个热点key失效，导致大量请求全部转向数据库，导致数据库压力过大。

**解决方案**

1. 对热点key设置永不过期。
2. 加互斥锁，缓存中没有热点key对应的数据时，等待100ms，由获得锁的线程去读取数据库然后设置缓存。



## Q:解决缓存与数据库一致性问题？

> 分析缓存与数据库一致性问题需要考虑业务中具体的 读写 规模。

严格`数据库+缓存`一致性方案：

- 读写分离：读请求只访问缓存，写请求修改数据库和缓存
- **读请求和写请求串行化**，串行到一个**内存队列**中去。



### 常用的缓存更新策略

#### Cache Aside Pattern

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，**先更新数据库，然后再删除缓存**。

缺点：在更新数据库成功，删除缓存失败的情况下，数据会造成不一致。

缺点解决思路：**先删除缓存，再更新数据库**。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

### Reference

[如何保证数据库与缓存一致性](https://app.yinxiang.com/shard/s43/nl/13675070/f4ee0e90-4458-4a79-8c88-137c740c799b)

[石彬 双写一致方案](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-consistence.md)




### 事务

#### Redis事务的三个阶段

1. 事务开始 MULTI
2. 命令入队
3. 事务执行 EXEC

事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队

#### Redis事务相关命令

Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的

Redis会将一个事务中的所有命令序列化，然后按顺序执行。

1. **redis 不支持回滚**，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。
2. **如果在一个事务中的命令出现错误，那么所有的命令都不会执行**；
3. **如果在一个事务中出现运行错误，那么正确的命令会被执行**。

- WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。
- MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。
- EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
- 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
- UNWATCH命令可以取消watch对所有key的监控。

#### Redis事务保证原子性吗，支持回滚吗

Redis中，单条命令是原子性执行的，但**事务不保证原子性，且没有回滚**。事务中任意命令执行失败，其余的命令仍会被执行。

### 集群方案

#### Redis哈希槽概念

Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。

在redis节点发送心跳包时需要把所有的槽放到这个心跳包里，以便让节点知道当前集群信息，16384=16k，在发送心跳包时使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 16K），也就是说使用2k的空间创建了16k的槽数。

详解：[为什么Redis集群有16384个槽](https://www.cnblogs.com/rjzheng/p/11430592.html)

#### Redis集群最大节点个数是多少

16384



### 其他问题

[Redis面试题](https://cloud.tencent.com/developer/article/1612347)

#### Redis与Memcached的区别

[redis和memcached的区别](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-single-thread-model.md)

#### 如何保证缓存与数据库双写时的数据一致性？

[如何保证数据库与缓存的双写一致](https://github.com/shishan100/Java-Interview-Advanced/blob/master/docs/high-concurrency/redis-consistence.md)

#### 布隆过滤器

##### 简介

布隆过滤器（Bloom Filter）是一个基于hash的概率性的数据结构，它实际上是一个很长的二进制向量，可以检查一个元素可能存在集合中，和一定不存在集合中。它的优点是空间效率高，但是有一定false positive(元素不在集合中，但是布隆过滤器显示在集合中)。

##### 原理

布隆过滤器就是一个长度为`m`个bit的bit数组，初始的时候每个bit都是0，另外还有`k`个hash函数。

当加入一个元素时，先用`k`个hash函数得到`k`个hash值，将`k`个hash值与bit数组长度取模得到个`k`个位置，将这`k`个位置对应的bit置位1。

参数设置参考

[白话布隆过滤器](https://blog.huoding.com/2020/06/22/825)

##### 实现

hash函数的选择，murmur3、FNV

[Redis实现布隆过滤器](https://learnku.com/articles/46442)