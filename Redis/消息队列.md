## Q:Redis消息队列关注的几个要点

### 1、消息保序

某些应用场景要求消息的顺序，如库存更新。

### 2、消息重复消费

- 产生原因：生产者因为网络抖动导致消息发送超时而重发。可能会产生多条消息。
- 解决方案：消费者需要在处理消息的时候做**幂等性**设计。例如使用**消息的唯一ID，或者版本号配合业务逻辑**来处理。

### 3、消息可靠性保障

#### 生产者发布异常

- 产生原因：生产者因网络问题或者自身问题发送失败
- 解决方案：需要有重试加报警机制。在重试一定次数后报警。

#### 消费者处理异常

- 产生原因：消费者读取消息后未处理完成就down机。
- 解决方案：使用List时，采用备份队列来保障，代价是增加了维护成本。使用Streams时采用ack方式，消费成功后告知中间件。

#### 中间件数据丢失

- 产生原因1：如果打开AOF并且是每秒写盘，因为这个写盘过程是异步的，Redis宕机时会丢失1秒的数据。而如果AOF改为同步写盘，那么写入性能会下降。
- 产生原因2：采用主从集群，如果写入量比较大，从库同步存在延迟，此时进行主从切换，也存在丢失数据的可能（从库还未同步完成主库发来的数据就被提成主库）。

### 4、redis消息队列适用场景

Redis可以用作队列，而且性能很高，部署维护也很轻量，但缺点是无法严格保数据的完整性。

适用于对于丢数据不敏感的业务，例如发短信、发通知的场景，可以采用Redis作队列。



## Q：Redis的list类型作为消息队列

- 消息保序：使用`LPUSH`、`RPOP`
- 阻塞读取：使用`BRPOP`。
  - 对应场景：list是空，这时候消费者就需要轮询来获取数据，这样就会增加redis的访问压力、增加消费端的cpu时间，而很多访问都是无用的。
  - 阻塞时间：如果设置非零的timeout，客户端会解除阻塞状态并且返回一个 nil 的多组合值。如果没有设置，则会一直阻塞，直到有另一个客户端对给定的这些key执行`LPUSH`命令。
- 重复消息处理：生产者实现全局唯一ID
- 消息可靠性：使用`BRPOPLPUSH`命令。
  - `RPOPLPUSH`它的两个参数如果是相同的队列键，就会构成**旋转队列**，下一个周期再次执行一次。为了控制队列的长度，客户端执行成功后需要(`LREM`)将对应的值删掉。
- 适用场景：Redis5.0之前版本，消息总量小场景。

## Q:Redis的Streams类型作为消息队列

- 消息保序：使用`XADD`、`XREAD`
  - `XADD mqstream * repo 5`
- 阻塞读取：使用`XREAD BLOCK`
  - `XREAD BLOCK 100 STREAMS mqstream 1599203861727-0`

- 重复消息处理:streams支持自动生成全局唯一ID，也可以自己生成。
- 消息可靠性：使用`PENDING` list 自动留存消息，使用XPENDING进行查看，使用XACK确认消息。
- 适用场景：Redis-5.0及以后版本。消息总量大，需要消费组形式读取数据。

### 其他

- Streams在使用`XADD`生成消息的时候可以指定长度 maxlen 将老的消息干掉，确保不会超过指定长度。
- 不去调用`XACK`命令，消息会被放到 pending list( PEL ) 列表 中，当不确认场景变多，PEL 列表就会变大。

### Reference

[Redis Streams消息队列](https://app.yinxiang.com/shard/s43/nl/13675070/a55057f0-0fcb-4c32-967e-9f0b43d2da59)

[Redis Streams 介绍 包含与kafka对比](https://app.yinxiang.com/shard/s43/nl/13675070/15818f55-486b-4d56-8311-0b57e21826d0)



## Q:Redis的Sorted Set做排行榜

- zset中score的值为double类型，完全保证的有效数字是15位，16位只是部分数值有保证。

- redis本身对于有序集合的数据，会先按score排名(从小到大)，然后再按字典序排序(0 ~9 ， A ~Z，a ~ z)
- 如果需求中有对分数和时间严格区分排名的需求，比如：同一分数，较早达到的排前面。可以采用：分数+时间戳的方式解决。
  - 时间戳选取1：在分数绝对不可能超过5位的情况下。秒是10位，毫秒13位。用最大时间戳去减去当前时间计算。
  - 时间戳选取2：分数可能会到9位(上亿)的大V粉丝刷分场景。优先满足分数计算，对于剩下的6位数字用作秒存储，大约11天。
  
  

## Q:Redis的Sorted Set做延时消息

#### 实现

- 集合内value存消息体，score存储时间戳。
- 某个线程去选取第一个key,如果该key值的score雄安于等于当前时间戳就消费。
- 消费完成后删除消息。

#### 注意事项：

- 查找和删除消息并不是原子操作。

[实时热点功能](https://blog.csdn.net/xindoo/article/details/79946492)
