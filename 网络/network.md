【计算机网络进阶路线】

网络相关知识点

[https://juejin.im/post/5b7be0b2e51d4538db34a51e](https://juejin.im/post/5b5f20686fb9a04f844adbdd)

计算机网络问题面试集锦

https://blog.csdn.net/justloveyou_/article/details/78303617

**http**和**https**的区别

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；

资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；

开销：Https通信需要证书，而证书一般需要向认证机构购买；

什么是**HTTPS**

https://mp.weixin.qq.com/s/1ojSrhc9LZV8zlX6YblMtA

对称加密和非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

　　由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

常见对称加密：

DES、3DES、AES、Blowfish、IDEA、RC5、RC6

常见非对称加密：

RSA、DSA、ECC

三次握手和四次分手

https://github.com/jawil/blog/issues/14

为什么**TCP**链接需要三次握手，两次不可以吗

为了防止 **已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

　　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这时，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。

**TCP**协议如何保证传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。

对于可靠性，TCP通过以下方式进行保证：

**数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；

**对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

**丢弃重复数据**：对于重复数据，能够丢弃重复数据；

**应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

**超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

**流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

客户端不断进行请求链接会怎么样？**DDOS**攻击？

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

DDOS攻击：

客户端向服务端发送请求链接数据包

服务端向客户端发送确认数据包

客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

DDOS预防(无法根治，除非不使用TCP)：

加宽带、封IP、CDN服务

限制同时打开SYN半链接的数目

缩短SYN半链接的Time out 时间

关闭不必要的服务

**GET**和**POST**区别

从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源。

从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 **请求头** 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 **请求体** 中。

从安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。

**TCP**和**UDP**区别

TCP是面向连接的，UDP是无连接的；

TCP是可靠的，UDP是不可靠的；

TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；

TCP是面向字节流的，UDP是面向报文的；

TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信

TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；

**TCP**的拥堵处理

https://blog.csdn.net/justloveyou_/article/details/78303617

**Session**和**Cookie**的对比

实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

**SQL** 注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**SQL**注入攻击的整体思路

寻找到SQL注入的位置；判断服务器类型和后台数据库类型；针对不通的服务器和数据库特点进行SQL注入攻击。

**SQL**注入攻击实例

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”; 因此，当输入了上面的用户名和密码，上面的SQL语句变成：SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’。分析上述SQL语句我们知道，

username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**SQL**注入攻击的应对方法

预编译；

正则表达式过滤对应的参数

**XSS**攻击

◦ XSS攻击的危害

◦ XSS攻击的原因解析

◦ XSS攻击分类

◦ 修复漏洞方针

**OSI**网络体系结构与**TCP/IP**协议模型

◦

**TCP**和**UDP**分别对应的常见应用层协议

TCP对应的应用层协议：

FTP：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。

Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。

SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。

HTTP：从Web服务器传输超文本到本地浏览器的传送协议。

UDP层对应的协议：

DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。

SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。

TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口69上使用UDP服务。

网络层的**ARP**协议(链路层协议)工作原理

**网络层的****ARP****协议完成了****IP****地址与物理地址的映射。**首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。

**IP**地址的分类

https://blog.csdn.net/justloveyou_/article/details/78303617

**IP**地址与物理地址

物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，ARP协议用于IP地址和物理地址的对应。

常见状态码

从**url**输入到页面展现到底发生什么

https://juejin.im/post/5c773dd251882519610194c1

**Https**的通信流程（图解**HTTP**）

客户端向服务器发起SSL通信，报文中包含客户端支持的SSL的指定版本，加密组件列表（所使用的加密算法及密钥长度）

服务器的响应报文中，包含SSL版本以及加密组件，服务器的加密组件内容是从客户端发来的加密组件列表中筛选出来的，服务器还会发一个公开密钥并且带有公钥证书

客户端拿到服务器的公开密钥，并验证其公钥证书（使用浏览器中已经植入的CA公开密钥）

如果验证成功，客户端生成一个Pre-master secret随机密码串，这个随机密码串其实就是之后通信要用的对称密钥，并用服务器的公开密钥进行加密，发送给服务器，以此通知服务器，之后的报文都会通过这个对称密钥来加密

同时，客户端用约定好的hash算法计算握手消息，然后用生成的密钥进行加密，一起发送给服务器

服务器收到客户端发来的的公开密钥加密的对称密钥，用自己的私钥对其解密拿到对称密钥，再用对称密钥解析握手消息，验证hash值是否与客户端发来的一致。如果一致，则通知客户端SSL握手成功

之后的数据交互都是HTTP通信（当然通信会获得SSL保护），且数据都是通过对称密钥来加密（这个密钥不会每次都发，在握手的过程中，服务器已经知道了这个对称密钥，再有数据来时，服务器知道这些数据就是通过对称密钥加密的，于是就直接解密了）

长连接与短连接

https://www.cnblogs.com/0201zcr/p/4694945.html