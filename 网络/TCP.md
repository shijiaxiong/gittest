## Q: TCP 端口号的分类

### 服务端使用的端口

####  熟知端口号

- 取值范围：0 - 1023

- 常见的端口号

| 应用程序   | FTP    | TELNET | SMTP | DNS  | TFTP | HTTP   | HTTPS   | SNMP |
| ---------- | ------ | ------ | ---- | ---- | ---- | ------ | ------- | ---- |
| 熟知端口号 | **21** | 23     | 25   | 53   | 69   | **80** | **443** | 161  |

#### 登记端口号

- 取值范围：1024 - 49151
- 这类端口没有熟知的应用程序使用，但是需要在IANA按照规定的手续登记，以防重复。49151是65535的四分之三。

### 客户端使用的端口号

- 取值范围：49152 - 65535
- 这类端口仅在客户端进程运行时才动态选择。



## Q:TCP 报文结构

![](/Users/shijiaxiong/web/interview_knowledge/网络/static/9.png)

![](/Users/shijiaxiong/web/interview_knowledge/网络/static/10.png)

- TCP首部的数据结构，如果不计入选项字段，首部是20个字节。
- 源端口号：2个字节，16位。告诉主机该报文来自哪里，客户端通常使用系统自动选择的临时端口号。
- 目标端口：2个字节，16位。告诉主机该报文传给哪个应用程序，服务器通常使用知名端口号。
- **序号(Sequence Number)**：占4字节，32位。指的是本报文段所发送数据的第一个字节的序号。从序号范围看，TCP协议可对4GB的数据进行编号，一般情况下可保证当序号重复使用时，旧序号的数据早已经通过网络达到终点或者丢失。
- **确认号(Acknowledgemt Number)**：占4字节，32位。表示期望收到对方下一个报文段的序号值。
- **首部长度(Offset)**：4位，范围是0-15，单位32bit。指出了 TCP报文段的数据起始处 距离 TCP报文的起始处 有多远。
- 一个数据偏移量 = 4 byte，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 byte，这也侧面限制了 TCP 首部的最大长度。
- **保留位**：占6位。保留为今后使用，暂时全部为0。
- **标志位**：一共有 6 个，分别占 1 位，共 6 位。
- **紧急URG(Urgent)**：当URG=1的时候表示紧急指针有效。它告诉系统此报文段中有紧急数据，应尽快传送，而不要按原来的排队顺序来传送。URG要与紧急数据指针配合使用。
  - **ACK(Acknowlegemt)**：ACK=1的时候确认号(Acknowledgemt Number)有效。TCP规定，在连接建立后所有传送的报文段都必须把ACK设置为1。
  - **推送PSH(Push)**：当 PSH = 1 的时候，表示该报文段高优先级，接收方 TCP 应该尽快推送给接收应用程序，而不用等到整个 TCP 缓存都填满了后再交付。
  - **复位 RST (Reset)**：当 RST = 1 的时候，表示 TCP 连接中出现严重错误，需要释放并重新建立连接。
  - **同步SYN(SYNchronization)**：当 SYN = 1 的时候，表明这是一个请求连接报文段。可以理解为只是在建立连接的第一和第二步为1。其他时候为0。
  - **终止FIN(Finis)**：当 FIN = 1 时，表示此报文段的发送方的数据已经发送完毕，并要求释放 TCP 连接。
- **接收窗口**(Window Size)：2个字节。表示现在允许对方发送的数据量，告诉对方**本地TCP接收缓冲区还能容纳多少字节的数据**，这样对方就可以控制发送数据的速度。
- **校验和(TCP  Checksum)**：2个字节。由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，如果损坏这丢弃。检验范围包括首部和数据两部分。
- **紧急数据指针(Urgent Pointer)**：2个字节。仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。
- 选项部分：其最大长度可根据TCP首部长度进行推算。TCP首部长度用4位表示，那么选项部分最长为：(2^4-1)*4-20=40字节。
  选项部分的应用：
  - MSS最大报文段长度(Maxium Segment Size)：指明数据字段的最大长度，数据字段的长度加上TCP首部的长度才等于整个TCP报文段的长度。MSS值指示自己期望对方发送TCP报文段时那个数据字段的长度。通信双方可以有不同的MSS值。如果未填写，默认采用536字节。MSS只出现在SYN报文中。即：MSS出现在SYN=1的报文段中。
    窗口扩大选项(Windows Scaling)：由于TCP首部的窗口大小字段长度是16位，所以其表示的最大数是65535。但是随着时延和带宽比较大的通信产生（如卫星通信），需要更大的窗口来满足性能和吞吐率，所以产生了这个窗口扩大选项。
  - SACK选择确认项(Selective Acknowledgements)：用来确保只重传缺少的报文段，而不是重传所有报文段。比如主机A发送报文段1、2、3，而主机B仅收到报文段1、3。那么此时就需要使用SACK选项来告诉发送方只发送丢失的数据。那么又如何指明丢失了哪些报文段呢？使用SACK需要两个功能字节。一个表示要使用SACK选项，另一个指明这个选项占用多少字节。描述丢失的报文段2，是通过描述它的左右边界报文段1、3来完成的。而这个1、3实际上是表示序列号，所以描述一个丢失的报文段需要64位即8个字节的空间。那么可以推算整个选项字段最多描述(40-2)/8=4个丢失的报文段。
  - 时间戳选项（Timestamps）：可以用来计算RTT(往返时间)，发送方发送TCP报文时，把当前的时间值放入时间戳字段，接收方收到后发送确认报文时，把这个时间戳字段的值复制到确认报文中，当发送方收到确认报文后即可计算出RTT。也可以用来防止回绕序号PAWS，也可以说可以用来区分相同序列号的不同报文。因为序列号用32为表示，每2^32个序列号就会产生回绕，那么使用时间戳字段就很容易区分相同序列号的不同报文。
  - NOP(NO-Operation)：它要求选项部分中的每种选项长度必须是4字节的倍数，不足的则用NOP填充。同时也可以用来分割不同的选项字段。如窗口扩大选项和SACK之间用NOP隔开。

## Q: TCP 连接的建立

> 其实，网络上的传输是没有连接的，TCP 也是一样的。
> 而 TCP 所谓的「连接」，其实只不过是在通信的双方维护一个「连接状态」，让它看上去好像有连接一样。
>
> TCP 的整个交流过程可以总结为：先建立连接，然后传输数据，最后释放链接。

### 三次握手

最初的时候，两端都处于 **CLOSED** 的状态，然后服务器打开了 TCP 服务，进入 **LISTEN** 状态，监听特定端口，等待客户端的 TCP 请求。

![](./static/WX20210511-181439@2x.png)

#### 建立连接的过程

**第一次握手**： 客户端主动打开连接，发送 TCP 报文，进行第一次握手，然后进入 **SYN_SEND** 状态，等待服务器发回确认报文。
这时首部的同步位 SYN = 1，同时初始化一个序号 seq = x。
TCP 规定，SYN 报文段(即SYN=1的报文段)不能携带数据，但会消耗一个序号。

**第二次握手**： 服务器收到了 SYN 报文，如果同意建立连接，则向客户端发送一个确认报文，然后服务器进入 **SYN_RCVD** 状态。
这时首部的 SYN = 1，ACK = 1，而确认号ack = x + 1，同时也为自己初始化一个序号 seq = y。
这个报文同样不携带数据。

**第三次握手**：
客户端收到了服务器发过来的确认报文，还要向服务器给出确认，然后进入 **ESTABLISHED** 状态。
这时首部的 SYN 不再置为 1，而 ACK = 1，确认号 ack = y + 1，序号 seq = x + 1。
第三次握手，一般会携带真正需要传输的数据，当服务器收到该数据报文的时候，就会同样进入 **ESTABLISHED** 状态。 此时，TCP 连接已经建立。

如果不携带数据则不消耗序列号，下一个数据报文段的序号仍是seq = x + 1。

#### 客户端为什么要最后再发送一次确认呢？或者说为什么要三次握手？

为了防止 **已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

### 四次挥手

TCP 有一个特别的概念叫做**半关闭**，这个概念是说，TCP 的连接是全双工（可以同时发送和接收）的连接，因此在关闭连接的时候，必须关闭传送和接收两个方向上的连接。
客户端给服务器发送一个携带 FIN 的 TCP 结束报文段，然后服务器返回给客户端一个 确认报文段，同时发送一个 结束报文段，当客户端回复一个 确认报文段 之后，连接就结束了。

![](./static/WX20210511-183132@2x.png)



#### 释放连接的过程

在结束之前，通信双方都是处于 **ESTABLISHED** 状态，然后其中一方主动断开连接。
下面假如客户端先主动断开连接。

**第一次挥手：**

客户端向服务器发送结束报文段，然后进入 **FIN_WAIT_1** 状态。
此报文段 FIN = 1， seq = u。FIN报文段不携带数据，也消耗一个序号。

**第二次挥手：**

服务端收到客户端的结束报文段，然后发送确认报文段，进入 **CLOSE_WAIT** 状态。
此报文段 ACK = 1， seq = v，ack = u + 1。

这个时候TCP连接处于**半关闭**状态，即客户端已经没有数据要发送了，但服务端若发送数据，客户端仍要接收。

客户端收到该报文，会进入 **FIN_WAIT_2** 状态。

**第三次挥手：**

同时服务端向客户端发送结束报文段，然后进入 **LAST_ACK** （最后确认）状态。
此报文段 FIN = 1，seq = w(在半关闭状态服务端可能又发送了一些数据)，ack = u + 1。

**第四次挥手：**

客户端收到服务端的结束报文段，然后发送确认报文段，进入 **TIME_WAIT** 状态，经过 2MSL 之后，自动进入 **CLOSED** 状态。
此报文段 ACK = 1,ack = w + 1，seq = u + 1(根据TCP标准，第一次发送的FIN报文要消耗一个序列号)。

服务端收到该报文之后，进入 **CLOSED** 状态。

#### 为什么客户端在TIME-WAIT状态要等2MSL的时间才关闭？

- 为了保证客户端发送的最后一个ACK报文段能够到达服务端。
- 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。



## Q:TCP 可靠性交付的实现

> 滑动窗口、超时重传、流量控制、拥塞控制

- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- **超时重传**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。
- **拥塞控制：**当网络拥塞时，减少数据的发送。



各自的实现方式



## Reference

[理解TCP和UDP](https://jerryc8080.gitbooks.io/understand-tcp-and-udp/content/)